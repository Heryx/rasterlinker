# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GPR
                                 A QGIS plugin
 GPR
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-23
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Giuseppe
        email                : guarino.archeo@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


# -*- coding: utf-8 -*-
"""
GPR - QGIS Plugin Implementation
"""

from qgis.PyQt.QtCore import QSettings, QCoreApplication, Qt, QSize
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QFileDialog, QAbstractItemView, QDockWidget, QInputDialog
from qgis.core import (
    QgsPointXY,
    QgsPointLocator,
    QgsApplication,
    QgsProject,
    QgsRasterLayer,
    QgsSnappingConfig,
    QgsTolerance,
    QgsLayerTreeLayer,
    QgsLayerTreeGroup,
    QgsCoordinateTransform,
    QgsRectangle,
    QgsVectorLayer,
    QgsVectorFileWriter,
    QgsContrastEnhancement,
    QgsRasterMinMaxOrigin,
    QgsRasterBandStats,
    QgsPrintLayout,
    QgsLayoutItemMap,
    QgsLayoutItemLabel,
    QgsLayoutExporter,
    QgsLayoutPoint,
    QgsLayoutSize,
    QgsUnitTypes,
    Qgis,
)
from PyQt5.QtWidgets import (
    QPushButton,
    QListWidgetItem,
    QLabel,
    QSizePolicy,
    QCheckBox,
    QWidget,
    QTabWidget,
    QGridLayout,
    QVBoxLayout,
)
from .grid_creator import create_oriented_grid
from .grid_selection_tool import GridSelectionTool
from .polygon_grid_creator import create_grid_from_polygon
from .polygon_draw_tool import PolygonDrawTool
from .grid_options_ui import build_grid_options_controls
from .project_manager_dialog import ProjectManagerDialog
from .project_catalog import load_catalog, create_raster_group, assign_timeslices_to_group, update_raster_group
from .group_import_dialog import GroupImportDialog

from .resources import *
from .gpr_linker_dialog import RasterLinkerDialog
import os.path
import re


class RasterLinkerPlugin:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor."""
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.actions = []
        self.menu = self.tr(u'&RasterLinker')
        self.first_start = None
        self.dlg = None
        self.dock_widget = None
        self.settings = QSettings()
        self.settings_group = "RasterLinker"
        self.settings_key_active_project = "RasterLinker/active_project_root"
        self.settings_key_default_import_crs = "RasterLinker/default_import_crs_authid"
        self.grid_use_snap = True
        self.grid_snap_mode = "all"
        self.grid_snap_tolerance = 12.0
        self.grid_snap_units = "pixels"
        self.grid_force_orthogonal = False
        self.grid_relative_orthogonal = False
        self.keep_source_polygon = True
        self.grid_dimension_mode = "ask"
        self.grid_internal_enabled = True
        self.snap_checkbox = None
        self.snap_mode_combo = None
        self.snap_tolerance_spin = None
        self.snap_units_combo = None
        self.ortho_checkbox = None
        self.ortho_base_checkbox = None
        self.keep_area_checkbox = None
        self.dimension_mode_combo = None
        self.help_button = None
        self.export_button = None
        self.base_angle_label = None
        self.length_label = None
        self.internal_grid_checkbox = None
        self.name_raster_panel = None
        self.name_raster_title = None
        self.name_raster_lines = []
        self.group_tools_label = None
        self.image_tools_label = None
        self.tools_tabs = None
        self.bottom_controls_widget = None
        self.dialog_main_layout = None
        self.left_nav_widget = None
        self._is_narrow_layout = None
        self.coord_x0_label = None
        self.coord_x1_label = None
        self.coord_y0_label = None
        self.coord_y1_label = None
        self.cell_x_label = None
        self.cell_y_label = None
        self.last_area_layer = None
        self.last_grid_layer = None
        self.project_manager_dialog = None
        self.plugin_layer_root_name = "RasterLinker"

    # Translation helper
    def tr(self, message):
        return QCoreApplication.translate('RasterLinker', message)

    # Add actions to the toolbar/menu
    def add_action(self, icon_path, text, callback, parent=None):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        self.iface.addToolBarIcon(action)
        self.iface.addPluginToMenu(self.menu, action)
        self.actions.append(action)
        return action

    def initGui(self):
        """Initialize the GUI."""
        icon_path = ':/plugins/gpr_linker/icon.png'
        self.add_action(icon_path, text=self.tr(u'Raster Linker'), callback=self.run, parent=self.iface.mainWindow())
        pm_action = self.add_action(
            icon_path,
            text=self.tr(u'RasterLinker Project Manager'),
            callback=self.open_project_manager,
            parent=self.iface.mainWindow(),
        )
        pm_icon = self._qgis_theme_icon(
            "mActionProjectProperties.svg",
            "mActionOptions.svg",
            "mActionProjectOpen.svg",
        )
        if not pm_icon.isNull():
            pm_action.setIcon(pm_icon)
        self.first_start = True

    def unload(self):
        """Unload the plugin."""
        if self.dlg is not None:
            self._save_ui_settings()
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&RasterLinker'), action)
            self.iface.removeToolBarIcon(action)
        if self.dock_widget is not None:
            self.iface.removeDockWidget(self.dock_widget)
            self.dock_widget.deleteLater()
            self.dock_widget = None
            self.dlg = None

    def run(self):
        """Esegue il plugin."""
        if self.first_start:
            self.first_start = False
            self.dlg = RasterLinkerDialog()
            self.dlg.on_resized = self._on_dialog_resized
            self.dock_widget = QDockWidget(self.tr(u"Raster Linker"), self.iface.mainWindow())
            self.dock_widget.setObjectName("RasterLinkerDockWidget")
            self.dock_widget.setFeatures(
                QDockWidget.DockWidgetMovable
                | QDockWidget.DockWidgetFloatable
                | QDockWidget.DockWidgetClosable
            )
            self.dock_widget.setWidget(self.dlg)
            self.dock_widget.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dock_widget)
            self._tabify_with_existing_right_dock()
            self._ensure_dialog_main_layout()
            self._init_name_raster_panel()
            self.populate_group_list()
            self.dlg.groupListWidget.setSelectionMode(QAbstractItemView.ExtendedSelection)
            self.dlg.createGridButton.setEnabled(True)
            self.dlg.selectGridPointsButton.setEnabled(True)
            self.dlg.selectGridPointsButton.setText("Set Orientation")
            self.dlg.selectGridPointsButton.setMinimumWidth(120)
            if hasattr(self.dlg, "Ok"):
                self.dlg.Ok.hide()
            if hasattr(self.dlg, "openButton"):
                self.dlg.openButton.hide()
            self.dlg.lineEditDistanceX.setEnabled(True)
            self.dlg.lineEditDistanceY.setEnabled(True)
            self.dlg.lineEditAreaNames.setEnabled(True)
            self.dlg.lineEditX0Y0.setEnabled(True)
            self.dlg.lineEditX1Y0.setEnabled(True)
            self.dlg.lineEditY0.setEnabled(True)
            self.dlg.lineEditX0Y1.setEnabled(True)
            if self.internal_grid_checkbox is None:
                self.internal_grid_checkbox = QCheckBox("Internal grid", self.dlg)
                self.internal_grid_checkbox.setToolTip(
                    "If enabled, create internal cells using Cell X/Cell Y. "
                    "If disabled, create only the base area from x0/x1/y0/y1."
                )
                self.internal_grid_checkbox.toggled.connect(self._on_internal_grid_toggled)

            # Collega i segnali ai metodi
            self.dlg.createGroupButton.clicked.connect(self.create_group)
            #self.dlg.moveRasterButton.clicked.connect(self.move_rasters)
            #self.dlg.groupListWidget.itemClicked.connect(self.on_group_selected)
            self.dlg.groupListWidget.itemSelectionChanged.connect(self.on_group_selection_changed)
            if hasattr(self.dlg, "openButton"):
                self.dlg.openButton.clicked.connect(self.load_raster)
            self.dlg.selectGridPointsButton.clicked.connect(self.activate_grid_selection_tool)
            if hasattr(self.dlg, "moveRasterButton"):
                self.dlg.moveRasterButton.clicked.connect(self.move_rasters)

            self.dlg.createGridButton.clicked.connect(self.create_grid_from_polygon_layer)

            self.dlg.zoomSelectedGroupsButton.clicked.connect(self.zoom_to_selected_groups)
            self.dlg.zoomSelectedGroupsButton.setText("Load Groups")
            self.dlg.zoomSelectedGroupsButton.setToolTip(
                "Load selected plugin groups into the QGIS layer tree."
            )
            self.dlg.zoomSelectedGroupsButton.setStatusTip("Load selected plugin groups")
            self.import_groups_button = QPushButton("Manage")
            self.import_groups_button.setToolTip("Open group manager to load/unload plugin groups.")
            self.import_groups_button.setStatusTip("Open group manager")
            self.import_groups_button.clicked.connect(self.open_group_import_dialog)
            self.dlg.gridLayout.addWidget(self.import_groups_button, 1, 1, 1, 1)
            self.enhance_minmax_button = QPushButton("Enhance Range")
            self.enhance_minmax_button.setToolTip("Apply Min/Max enhancement to loaded rasters.")
            self.enhance_minmax_button.setStatusTip("Apply min/max enhancement")
            self.enhance_minmax_button.clicked.connect(self.enhance_loaded_images_minmax)
            self.dlg.gridLayout.addWidget(self.enhance_minmax_button, 5, 0, 1, 1)
            self.enhance_batch_button = QPushButton("Batch Enhance")
            self.enhance_batch_button.setToolTip("Apply batch enhancement with selected method.")
            self.enhance_batch_button.setStatusTip("Apply batch enhancement")
            self.enhance_batch_button.clicked.connect(self.enhance_batch_options)
            self.dlg.gridLayout.addWidget(self.enhance_batch_button, 5, 1, 1, 1)
            self.save_style_button = QPushButton("Save Style")
            self.save_style_button.setToolTip("Save style for active group.")
            self.save_style_button.setStatusTip("Save style for active group")
            self.save_style_button.clicked.connect(self.save_selected_group_style)
            self.dlg.gridLayout.addWidget(self.save_style_button, 6, 0, 1, 1)
            self.load_style_button = QPushButton("Load Style")
            self.load_style_button.setToolTip("Load saved style for active group.")
            self.load_style_button.setStatusTip("Load style for active group")
            self.load_style_button.clicked.connect(self.load_selected_group_style)
            self.dlg.gridLayout.addWidget(self.load_style_button, 6, 1, 1, 1)
            self.export_layout_button = QPushButton("Export PDF")
            self.export_layout_button.setToolTip("Quick PDF export for selected group.")
            self.export_layout_button.setStatusTip("Export quick layout PDF")
            self.export_layout_button.clicked.connect(self.export_group_layout_quick)
            self.dlg.gridLayout.addWidget(self.export_layout_button, 7, 0, 1, 2)

            if hasattr(self.dlg, "groupNameEdit"):
                self.dlg.groupNameEdit.setPlaceholderText("New group name")
                self.dlg.groupNameEdit.setToolTip("Enter a name and click Create Group.")
            self.dlg.dial2.setToolTip("Navigation dial: switch visible rasters in selected groups.")
            self.dlg.Dial.setToolTip("Navigation slider: switch visible rasters in selected groups.")

            # Preimposta valori predefiniti
            self.dlg.lineEditDistanceX.setText("1.0")  # Valore predefinito per distanza X
            self.dlg.lineEditDistanceY.setText("1.0")  # Valore predefinito per distanza Y
            self.dlg.lineEditAreaNames.setPlaceholderText("Area name | cell prefix")
            self.dlg.lineEditAreaNames.setToolTip(
                "Area naming field. Format: AreaName|CellPrefix (prefix optional)."
            )
            self.dlg.lineEditAreaNames.setAccessibleName("lineEditAreaNames")
            self._build_tools_tabs()
            self._build_bottom_controls_layout()
            self._load_ui_settings()
            if self.internal_grid_checkbox is not None:
                self.internal_grid_checkbox.setChecked(bool(self.grid_internal_enabled))
            self._build_grid_options_controls()
            self._swap_drawing_and_navigation_sections()
            self._sync_grid_options_from_controls()
            self._connect_persistent_fields()
            self._tune_visual_layout()
            self._apply_responsive_main_layout(self.dlg.width())
            self._apply_button_icons()

            # Collega il dial alla funzione di aggiornamento
            self.dlg.Dial.valueChanged.connect(self.update_visibility_with_dial)
            self.dlg.dial2.valueChanged.connect(self.update_visibility_with_dial)

        self.dock_widget.show()
        self._ensure_dock_in_right_area()
        self._tabify_with_existing_right_dock()
        self.dock_widget.raise_()
        self._apply_dock_constraints()
        if self.dlg is not None:
            self._apply_responsive_main_layout(self.dlg.width())
        if self.dlg is not None:
            self._apply_button_icons()
        if not self._active_project_root():
            self._notify_info(
                "No active project linked. Open 'RasterLinker Project Manager' and create/open a project.",
                duration=8,
            )

    def open_project_manager(self):
        if self.project_manager_dialog is None:
            self.project_manager_dialog = ProjectManagerDialog(
                self.iface,
                self.iface.mainWindow(),
                on_project_updated=self._on_project_manager_updated,
            )
        self.project_manager_dialog.show()
        self.project_manager_dialog.raise_()
        if self.dlg is not None:
            self.populate_group_list()

    def _on_project_manager_updated(self):
        if self.dlg is not None:
            self.populate_group_list()
            self.populate_raster_list_from_selected_groups()

    def _apply_dock_constraints(self):
        if self.dock_widget is None or self.dlg is None:
            return
        # Keep constraints lightweight to avoid disturbing QGIS global dock layout.
        self.dlg.setMinimumWidth(380)
        self.dlg.setMinimumHeight(0)
        self.dlg.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.dock_widget.setMinimumWidth(380)
        self.dock_widget.setMinimumHeight(0)

    def _on_dialog_resized(self, size):
        width = size.width() if hasattr(size, "width") else (self.dlg.width() if self.dlg is not None else 0)
        self._apply_responsive_main_layout(width)

    def _apply_responsive_main_layout(self, width):
        if self.dlg is None or not hasattr(self.dlg, "gridLayout_3"):
            return
        is_narrow = width < 760
        if self._is_narrow_layout is is_narrow:
            return

        gl3 = self.dlg.gridLayout_3
        if is_narrow:
            # Stack sections to avoid clipping on narrow/half-screen layouts.
            gl3.addLayout(self.dlg.verticalLayout_3, 0, 0, 1, 1)
            gl3.addWidget(self.dlg.widget, 1, 0, 1, 1)
            gl3.addLayout(self.dlg.gridLayout, 2, 0, 1, 1)
            if hasattr(self.dlg, "line"):
                self.dlg.line.hide()
            gl3.setColumnStretch(0, 1)
            gl3.setColumnStretch(1, 0)
            gl3.setColumnStretch(2, 0)
            gl3.setColumnStretch(3, 0)
            gl3.setRowStretch(0, 1)
            gl3.setRowStretch(1, 0)
            gl3.setRowStretch(2, 0)
            gl3.setRowStretch(3, 0)
            if hasattr(self.dlg, "rasterListWidget"):
                self.dlg.rasterListWidget.setMinimumWidth(160)
            if hasattr(self.dlg, "groupListWidget"):
                self.dlg.groupListWidget.setMinimumWidth(160)
            self.dlg.dial2.setMinimumSize(130, 130)
            self.dlg.dial2.setMaximumSize(170, 170)
            self.dlg.Dial.setMinimumHeight(34)
            self.dlg.Dial.setMaximumHeight(38)
            if hasattr(self.dlg, "widget"):
                self.dlg.widget.setMinimumHeight(0)
        else:
            # Restore wide two-column layout.
            gl3.addLayout(self.dlg.verticalLayout_3, 0, 0, 2, 1)
            gl3.addWidget(self.dlg.widget, 0, 2, 1, 2)
            gl3.addLayout(self.dlg.gridLayout, 1, 2, 1, 2)
            if hasattr(self.dlg, "line"):
                self.dlg.line.show()
                gl3.addWidget(self.dlg.line, 0, 1, 2, 1)
            gl3.setColumnStretch(0, 8)
            gl3.setColumnStretch(1, 0)
            gl3.setColumnStretch(2, 6)
            gl3.setColumnStretch(3, 0)
            gl3.setRowStretch(0, 0)
            gl3.setRowStretch(1, 0)
            gl3.setRowStretch(2, 0)
            gl3.setRowStretch(3, 1)
            if hasattr(self.dlg, "rasterListWidget"):
                self.dlg.rasterListWidget.setMinimumWidth(220)
            if hasattr(self.dlg, "groupListWidget"):
                self.dlg.groupListWidget.setMinimumWidth(220)
            self.dlg.dial2.setMinimumSize(160, 160)
            self.dlg.dial2.setMaximumSize(220, 220)
            self.dlg.Dial.setMinimumHeight(42)
            self.dlg.Dial.setMaximumHeight(46)
            if hasattr(self.dlg, "widget"):
                self.dlg.widget.setMinimumHeight(220)

        self._is_narrow_layout = is_narrow

    def _ensure_dock_in_right_area(self):
        if self.dock_widget is None:
            return
        if self.dock_widget.isFloating():
            return
        main_window = self.iface.mainWindow()
        try:
            area = main_window.dockWidgetArea(self.dock_widget)
            if area != Qt.RightDockWidgetArea:
                main_window.removeDockWidget(self.dock_widget)
                main_window.addDockWidget(Qt.RightDockWidgetArea, self.dock_widget)
        except Exception:
            pass

    def _tabify_with_existing_right_dock(self):
        if self.dock_widget is None:
            return
        main_window = self.iface.mainWindow()
        try:
            main_window.setDockNestingEnabled(True)
        except Exception:
            pass

        candidates = []
        for dock in main_window.findChildren(QDockWidget):
            if dock is self.dock_widget:
                continue
            if dock.isFloating():
                continue
            if main_window.dockWidgetArea(dock) != Qt.RightDockWidgetArea:
                continue
            candidates.append(dock)

        if not candidates:
            return

        tokens = (
            "browser",
            "processing",
            "style",
            "layer",
            "strumenti di processing",
            "stile layer",
        )

        def dock_score(dock):
            text = f"{dock.windowTitle()} {dock.objectName()}".lower()
            score = 0
            for token in tokens:
                if token in text:
                    score += 10
            if dock.isVisible():
                score += 3
            return score

        target = sorted(candidates, key=dock_score, reverse=True)[0]
        try:
            main_window.tabifyDockWidget(target, self.dock_widget)
        except Exception:
            # Fallback: keep standard dock placement.
            return

    def create_grid_from_polygon_layer(self):
        """
        Draw a polygon interactively and create a grid from it.
        """
        try:
            self._sync_grid_options_from_controls()
            # Activate polygon drawing tool
            self.polygon_draw_tool = PolygonDrawTool(self.iface.mapCanvas(), self)
            self.iface.mapCanvas().setMapTool(self.polygon_draw_tool)

            self._notify_info(
                "Draw area: left-click vertices, right-click/Enter to close, ESC to cancel. "
                "Oriented rectangle: first click origin, then D/middle-click for dimensions. "
                "Dock: Snap, Ortho 0/90, Mode. Name: Area|Prefix."
            )
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while activating drawing tool: {e}")

    
    def create_grid_from_drawn_polygon(self, polygon_layer):
        """
        Create a grid based on the polygon drawn by the user.
        """
        try:
            # Read spacing values from UI
            distance_x = float(self.dlg.lineEditDistanceX.text().strip())
            distance_y = float(self.dlg.lineEditDistanceY.text().strip())
            area_name, cell_prefix = self._get_grid_names_from_ui()
            polygon_layer.setName(area_name)
            if not self._confirm_planar_units_for_grid():
                return

            # Create grid
            grid_layer = create_grid_from_polygon(
                polygon_layer,
                distance_x,
                distance_y,
                area_name=area_name,
                cell_prefix=cell_prefix,
                max_cells=120000,
            )
            self.last_area_layer = polygon_layer
            self.last_grid_layer = grid_layer

            if not self.keep_source_polygon and QgsProject.instance().mapLayer(polygon_layer.id()) is not None:
                QgsProject.instance().removeMapLayer(polygon_layer.id())

            self._notify_info(f"Area '{area_name}' created. Cells with prefix '{cell_prefix}'.")
        except ValueError as ve:
            QMessageBox.warning(self.dlg, "Error", f"Error: {ve}")
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while creating grid: {e}")

    def _get_grid_names_from_ui(self):
        """
        Estrae i nomi da lineEditAreaNames.
        Formato supportato: "NomeArea|PrefissoCelle"
        Se manca il prefisso: "NomeArea" -> prefisso automatico.
        """
        raw_value = self.dlg.lineEditAreaNames.text().strip()
        if not raw_value:
            area_name = "Area_Indagine"
            return area_name, f"{area_name}_cell"

        if "|" in raw_value:
            parts = [p.strip() for p in raw_value.split("|", 1)]
            area_name = parts[0] or "Area_Indagine"
            cell_prefix = parts[1] or f"{area_name}_cell"
            return area_name, cell_prefix

        area_name = raw_value
        return area_name, f"{area_name}_cell"

    def _settings_key(self, key):
        return f"{self.settings_group}/{key}"

    def _load_ui_settings(self):
        self.grid_use_snap = self.settings.value(self._settings_key("grid/use_snap"), True, type=bool)
        self.grid_snap_mode = self.settings.value(self._settings_key("grid/snap_mode"), "all")
        self.grid_snap_tolerance = self.settings.value(self._settings_key("grid/snap_tolerance"), 12.0, type=float)
        self.grid_snap_units = self.settings.value(self._settings_key("grid/snap_units"), "pixels")
        self.grid_force_orthogonal = self.settings.value(self._settings_key("grid/force_orthogonal"), False, type=bool)
        self.grid_relative_orthogonal = self.settings.value(self._settings_key("grid/relative_orthogonal"), False, type=bool)
        self.keep_source_polygon = self.settings.value(self._settings_key("grid/keep_source_polygon"), True, type=bool)
        mode = self.settings.value(self._settings_key("grid/dimension_mode"), "ask")
        self.grid_dimension_mode = mode if mode in ("ask", "manual", "canvas") else "ask"
        self.grid_internal_enabled = self.settings.value(
            self._settings_key("grid/internal_enabled"),
            True,
            type=bool,
        )

        self.dlg.lineEditDistanceX.setText(
            self.settings.value(self._settings_key("grid/distance_x"), self.dlg.lineEditDistanceX.text())
        )
        self.dlg.lineEditDistanceY.setText(
            self.settings.value(self._settings_key("grid/distance_y"), self.dlg.lineEditDistanceY.text())
        )
        self.dlg.lineEditAreaNames.setText(
            self.settings.value(self._settings_key("grid/area_names"), "")
        )

    def _save_ui_settings(self):
        self._sync_grid_options_from_controls()
        self.settings.setValue(self._settings_key("grid/distance_x"), self.dlg.lineEditDistanceX.text().strip())
        self.settings.setValue(self._settings_key("grid/distance_y"), self.dlg.lineEditDistanceY.text().strip())
        self.settings.setValue(self._settings_key("grid/area_names"), self.dlg.lineEditAreaNames.text().strip())
        self.settings.setValue(self._settings_key("grid/use_snap"), self.grid_use_snap)
        self.settings.setValue(self._settings_key("grid/snap_mode"), self.grid_snap_mode)
        self.settings.setValue(self._settings_key("grid/snap_tolerance"), float(self.grid_snap_tolerance))
        self.settings.setValue(self._settings_key("grid/snap_units"), self.grid_snap_units)
        self.settings.setValue(self._settings_key("grid/force_orthogonal"), self.grid_force_orthogonal)
        self.settings.setValue(self._settings_key("grid/relative_orthogonal"), self.grid_relative_orthogonal)
        self.settings.setValue(self._settings_key("grid/keep_source_polygon"), self.keep_source_polygon)
        self.settings.setValue(self._settings_key("grid/dimension_mode"), self.grid_dimension_mode)
        self.settings.setValue(self._settings_key("grid/internal_enabled"), self.grid_internal_enabled)

    def _connect_persistent_fields(self):
        self.dlg.lineEditDistanceX.editingFinished.connect(self._save_ui_settings)
        self.dlg.lineEditDistanceY.editingFinished.connect(self._save_ui_settings)
        self.dlg.lineEditAreaNames.editingFinished.connect(self._save_ui_settings)
        if self.internal_grid_checkbox is not None:
            self.internal_grid_checkbox.toggled.connect(self._save_ui_settings)
        if self.snap_checkbox is not None:
            self.snap_checkbox.toggled.connect(self._save_ui_settings)
        if self.snap_mode_combo is not None:
            self.snap_mode_combo.currentIndexChanged.connect(self._save_ui_settings)
        if self.snap_tolerance_spin is not None:
            self.snap_tolerance_spin.valueChanged.connect(self._save_ui_settings)
        if self.snap_units_combo is not None:
            self.snap_units_combo.currentIndexChanged.connect(self._save_ui_settings)
        if self.ortho_checkbox is not None:
            self.ortho_checkbox.toggled.connect(self._save_ui_settings)
        if self.ortho_base_checkbox is not None:
            self.ortho_base_checkbox.toggled.connect(self._save_ui_settings)
        if self.keep_area_checkbox is not None:
            self.keep_area_checkbox.toggled.connect(self._save_ui_settings)
        if self.dimension_mode_combo is not None:
            self.dimension_mode_combo.currentIndexChanged.connect(self._save_ui_settings)
        if self.help_button is not None:
            self.help_button.clicked.connect(self.show_grid_help)
        if self.export_button is not None:
            self.export_button.clicked.connect(self.export_last_grid_to_gpkg)

    def _ensure_dialog_main_layout(self):
        if self.dlg is None:
            return
        if self.dialog_main_layout is not None:
            return
        if self.dlg.layout() is None:
            main_layout = QVBoxLayout(self.dlg)
            main_layout.setContentsMargins(6, 6, 6, 6)
            main_layout.setSpacing(10)
        else:
            main_layout = self.dlg.layout()
        if hasattr(self.dlg, "layoutWidget"):
            self.dlg.layoutWidget.setParent(self.dlg)
            self.dlg.layoutWidget.setMinimumSize(0, 0)
            self.dlg.layoutWidget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            main_layout.addWidget(self.dlg.layoutWidget, 1)
        self.dialog_main_layout = main_layout

    def _build_tools_tabs(self):
        if self.dlg is None or self.tools_tabs is not None:
            return

        for legacy_widget_name in ("openButton", "Ok"):
            legacy_widget = getattr(self.dlg, legacy_widget_name, None)
            if legacy_widget is not None:
                legacy_widget.hide()
                self.dlg.gridLayout.removeWidget(legacy_widget)

        tabs = QTabWidget(self.dlg.layoutWidget)
        tabs.setObjectName("toolsTabs")
        tabs.setDocumentMode(False)
        tabs.setUsesScrollButtons(False)

        group_tab = QWidget(tabs)
        group_layout = QGridLayout(group_tab)
        group_layout.setContentsMargins(6, 6, 6, 6)
        group_layout.setHorizontalSpacing(8)
        group_layout.setVerticalSpacing(6)
        group_layout.addWidget(self.dlg.zoomSelectedGroupsButton, 0, 0, 1, 1)
        group_layout.addWidget(self.import_groups_button, 0, 1, 1, 1)
        group_layout.addWidget(self.dlg.createGroupButton, 1, 0, 1, 1)
        if hasattr(self.dlg, "groupNameEdit"):
            group_layout.addWidget(self.dlg.groupNameEdit, 1, 1, 1, 1)
        group_layout.setColumnStretch(0, 1)
        group_layout.setColumnStretch(1, 1)
        group_layout.setRowStretch(0, 0)
        group_layout.setRowStretch(1, 0)
        group_layout.setRowStretch(2, 0)

        image_tab = QWidget(tabs)
        image_layout = QGridLayout(image_tab)
        image_layout.setContentsMargins(6, 6, 6, 6)
        image_layout.setHorizontalSpacing(8)
        image_layout.setVerticalSpacing(6)
        image_layout.addWidget(self.enhance_minmax_button, 0, 0, 1, 1)
        image_layout.addWidget(self.enhance_batch_button, 0, 1, 1, 1)
        image_layout.addWidget(self.save_style_button, 1, 0, 1, 1)
        image_layout.addWidget(self.load_style_button, 1, 1, 1, 1)
        image_layout.addWidget(self.export_layout_button, 2, 0, 1, 2)
        image_layout.setColumnStretch(0, 1)
        image_layout.setColumnStretch(1, 1)
        image_layout.setRowStretch(0, 0)
        image_layout.setRowStretch(1, 0)
        image_layout.setRowStretch(2, 0)
        image_layout.setRowStretch(3, 0)

        tabs.addTab(group_tab, "Groups")
        tabs.addTab(image_tab, "Images")
        tabs.tabBar().setExpanding(False)
        tabs.tabBar().setElideMode(Qt.ElideRight)
        tabs.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Maximum)
        tabs.setMinimumHeight(120)
        tabs.setMaximumHeight(150)

        if self.group_tools_label is not None:
            self.group_tools_label.hide()
            self.dlg.gridLayout.removeWidget(self.group_tools_label)
        if self.image_tools_label is not None:
            self.image_tools_label.hide()
            self.dlg.gridLayout.removeWidget(self.image_tools_label)

        self.dlg.gridLayout.addWidget(tabs, 0, 0, 1, 2)
        self.tools_tabs = tabs

    def _build_bottom_controls_layout(self):
        if self.dlg is None or self.bottom_controls_widget is not None:
            return

        self._ensure_dialog_main_layout()

        for legacy_label_name in ("labelx", "labelx_2", "labelx_3", "labelx_4", "labelx_5", "labelx_6"):
            legacy_label = getattr(self.dlg, legacy_label_name, None)
            if legacy_label is not None:
                legacy_label.hide()

        panel = QWidget(self.dlg)
        panel.setObjectName("gridDefinitionPanel")
        panel.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        panel.setMinimumHeight(185)
        panel_layout = QGridLayout(panel)
        panel_layout.setContentsMargins(8, 8, 8, 10)
        panel_layout.setHorizontalSpacing(10)
        panel_layout.setVerticalSpacing(8)

        self.coord_x0_label = QLabel("x0", panel)
        self.coord_x1_label = QLabel("x1", panel)
        self.coord_y0_label = QLabel("y0", panel)
        self.coord_y1_label = QLabel("y1", panel)
        self.cell_x_label = QLabel("Cell X (m)", panel)
        self.cell_y_label = QLabel("Cell Y (m)", panel)
        for label in (
            self.coord_x0_label,
            self.coord_x1_label,
            self.coord_y0_label,
            self.coord_y1_label,
            self.cell_x_label,
            self.cell_y_label,
        ):
            label.setStyleSheet("color: #202020; font-size: 9pt;")

        self.dlg.selectGridPointsButton.setParent(panel)
        self.dlg.lineEditX0Y0.setParent(panel)
        self.dlg.lineEditX1Y0.setParent(panel)
        self.dlg.lineEditY0.setParent(panel)
        self.dlg.lineEditX0Y1.setParent(panel)
        self.dlg.createGridButton.setParent(panel)
        self.dlg.lineEditAreaNames.setParent(panel)
        self.dlg.lineEditDistanceX.setParent(panel)
        self.dlg.lineEditDistanceY.setParent(panel)
        if self.internal_grid_checkbox is not None:
            self.internal_grid_checkbox.setParent(panel)

        panel_layout.addWidget(self.dlg.selectGridPointsButton, 0, 0, 2, 1)
        panel_layout.addWidget(self.coord_x0_label, 0, 1, 1, 1)
        panel_layout.addWidget(self.coord_x1_label, 0, 2, 1, 1)
        panel_layout.addWidget(self.dlg.lineEditX0Y0, 1, 1, 1, 1)
        panel_layout.addWidget(self.dlg.lineEditX1Y0, 1, 2, 1, 1)

        panel_layout.addWidget(self.coord_y0_label, 2, 1, 1, 1)
        panel_layout.addWidget(self.coord_y1_label, 2, 2, 1, 1)
        panel_layout.addWidget(self.dlg.lineEditY0, 3, 1, 1, 1)
        panel_layout.addWidget(self.dlg.lineEditX0Y1, 3, 2, 1, 1)

        panel_layout.addWidget(self.dlg.createGridButton, 4, 0, 1, 1)
        panel_layout.addWidget(self.dlg.lineEditAreaNames, 4, 1, 1, 1)
        if self.internal_grid_checkbox is not None:
            panel_layout.addWidget(self.internal_grid_checkbox, 4, 2, 1, 1, Qt.AlignLeft | Qt.AlignVCenter)

        panel_layout.addWidget(self.cell_x_label, 5, 1, 1, 1)
        panel_layout.addWidget(self.cell_y_label, 5, 2, 1, 1)
        panel_layout.addWidget(self.dlg.lineEditDistanceX, 6, 1, 1, 1)
        panel_layout.addWidget(self.dlg.lineEditDistanceY, 6, 2, 1, 1)

        panel_layout.setColumnMinimumWidth(0, 132)
        panel_layout.setColumnStretch(0, 0)
        panel_layout.setColumnStretch(1, 1)
        panel_layout.setColumnStretch(2, 1)
        panel_layout.setRowMinimumHeight(0, 18)
        panel_layout.setRowMinimumHeight(1, 32)
        panel_layout.setRowMinimumHeight(2, 18)
        panel_layout.setRowMinimumHeight(3, 32)
        panel_layout.setRowMinimumHeight(4, 34)
        panel_layout.setRowMinimumHeight(5, 18)
        panel_layout.setRowMinimumHeight(6, 32)

        self.bottom_controls_widget = panel
        if self.dialog_main_layout is not None:
            self.dialog_main_layout.addWidget(panel, 0)
        else:
            self.dlg.gridLayout_3.addWidget(panel, 2, 0, 1, 4)

    def _swap_drawing_and_navigation_sections(self):
        """
        Put Drawing Options on the right-top block and move Dial/Slider to the left column.
        """
        if self.dlg is None:
            return

        # Build left navigation widget once and host dial + slider there.
        if self.left_nav_widget is None:
            nav_widget = QWidget(self.dlg.layoutWidget)
            nav_layout = QVBoxLayout(nav_widget)
            nav_layout.setContentsMargins(0, 0, 0, 0)
            nav_layout.setSpacing(6)
            nav_layout.addWidget(self.dlg.dial2, 0, Qt.AlignHCenter)
            nav_layout.addWidget(self.dlg.Dial)
            self.left_nav_widget = nav_widget

        # Left column order: raster list, group list, navigation, name raster.
        if hasattr(self.dlg, "verticalLayout_3"):
            self.dlg.verticalLayout_3.removeWidget(self.dlg.widget)
            self.dlg.verticalLayout_3.removeWidget(self.left_nav_widget)
            self.dlg.verticalLayout_3.insertWidget(4, self.left_nav_widget)

        # Right-top hosts drawing options.
        if hasattr(self.dlg, "gridLayout_3"):
            self.dlg.gridLayout_3.addWidget(self.dlg.widget, 0, 2, 1, 2)

    def _tune_visual_layout(self):
        # Remove obsolete instruction block to recover vertical space.
        if hasattr(self.dlg, "textBrowser"):
            self.dlg.textBrowser.hide()
        if hasattr(self.dlg, "lebelstep"):
            self.dlg.lebelstep.hide()

        button_style = (
            "font-size: 9pt; "
            "padding: 4px 8px;"
        )
        label_style = "color: #202020; font-size: 9pt;"

        # Make navigation controls easier to use.
        self.dlg.dial2.setMinimumSize(160, 160)
        self.dlg.dial2.setMaximumSize(220, 220)
        self.dlg.dial2.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        self.dlg.dial2.setNotchTarget(2.0)
        self.dlg.Dial.setMinimumHeight(42)
        self.dlg.Dial.setMaximumHeight(46)
        if hasattr(self.dlg, "rasterListWidget"):
            self.dlg.rasterListWidget.setMinimumWidth(220)
            self.dlg.rasterListWidget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            self.dlg.rasterListWidget.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.dlg.rasterListWidget.setStyleSheet("font-size: 9pt;")
        if hasattr(self.dlg, "groupListWidget"):
            self.dlg.groupListWidget.setMinimumWidth(220)
            self.dlg.groupListWidget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            self.dlg.groupListWidget.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.dlg.groupListWidget.setStyleSheet("font-size: 9pt;")

        # Improve readability/consistency of layout-managed action buttons.
        for btn in [
            getattr(self, "import_groups_button", None),
            getattr(self, "enhance_minmax_button", None),
            getattr(self, "enhance_batch_button", None),
            getattr(self, "save_style_button", None),
            getattr(self, "load_style_button", None),
            getattr(self, "export_layout_button", None),
            self.dlg.zoomSelectedGroupsButton,
            self.dlg.createGroupButton,
            self.dlg.selectGridPointsButton,
            self.dlg.createGridButton,
        ]:
            if btn is not None:
                btn.setMinimumHeight(30)
                btn.setMinimumWidth(108)
                btn.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
                btn.setStyleSheet(button_style)
                btn.setIconSize(QSize(16, 16))

        # Compact right-side tools block to leave more visual room for drawing options.
        for btn in [
            self.dlg.zoomSelectedGroupsButton,
            getattr(self, "import_groups_button", None),
            self.dlg.createGroupButton,
            getattr(self, "enhance_minmax_button", None),
            getattr(self, "enhance_batch_button", None),
            getattr(self, "save_style_button", None),
            getattr(self, "load_style_button", None),
            getattr(self, "export_layout_button", None),
        ]:
            if btn is not None:
                btn.setMinimumHeight(28)
                btn.setMinimumWidth(96)

        if hasattr(self.dlg, "lineEditAreaNames"):
            self.dlg.lineEditAreaNames.setStyleSheet("font-size: 9pt; padding: 2px 4px;")
            self.dlg.lineEditAreaNames.setMinimumHeight(24)
        if self.internal_grid_checkbox is not None:
            self.internal_grid_checkbox.setStyleSheet(label_style)

        for edit_name in ("lineEditX0Y0", "lineEditX1Y0", "lineEditY0", "lineEditX0Y1", "lineEditDistanceX", "lineEditDistanceY", "groupNameEdit"):
            edit = getattr(self.dlg, edit_name, None)
            if edit is not None:
                edit.setMinimumHeight(24)
                edit.setStyleSheet("font-size: 9pt; padding: 2px 4px;")

        for label in (
            self.coord_x0_label,
            self.coord_x1_label,
            self.coord_y0_label,
            self.coord_y1_label,
            self.cell_x_label,
            self.cell_y_label,
        ):
            if label is not None:
                label.setStyleSheet(label_style)
        self._on_internal_grid_toggled(self.internal_grid_checkbox.isChecked() if self.internal_grid_checkbox is not None else True)

        if self.tools_tabs is not None:
            self.tools_tabs.setStyleSheet(
                "QTabBar::tab { font-size: 9pt; padding: 0px 4px; min-width: 48px; }"
            )

        for checkbox in (
            self.snap_checkbox,
            self.ortho_checkbox,
            self.ortho_base_checkbox,
            self.keep_area_checkbox,
        ):
            if checkbox is not None:
                checkbox.setStyleSheet("color: #202020; font-size: 9pt;")
        for input_widget in (
            self.snap_mode_combo,
            self.snap_tolerance_spin,
            self.snap_units_combo,
            self.dimension_mode_combo,
        ):
            if input_widget is not None:
                input_widget.setMinimumHeight(26)
                input_widget.setStyleSheet("font-size: 9pt;")
        for aux_btn in (self.help_button, self.export_button):
            if aux_btn is not None:
                aux_btn.setMinimumHeight(32)
                aux_btn.setMinimumWidth(86)
                aux_btn.setStyleSheet(button_style)

        if hasattr(self.dlg, "gridLayout"):
            self.dlg.gridLayout.setHorizontalSpacing(8)
            self.dlg.gridLayout.setVerticalSpacing(6)
            self.dlg.gridLayout.setColumnStretch(0, 1)
            self.dlg.gridLayout.setColumnStretch(1, 1)
            self.dlg.gridLayout.setContentsMargins(12, 0, 0, 0)
            self.dlg.gridLayout.setRowStretch(0, 0)
        if hasattr(self.dlg, "gridLayout_3"):
            self.dlg.gridLayout_3.setHorizontalSpacing(10)
            self.dlg.gridLayout_3.setVerticalSpacing(8)
            self.dlg.gridLayout_3.setColumnStretch(0, 8)
            self.dlg.gridLayout_3.setColumnStretch(1, 0)
            self.dlg.gridLayout_3.setColumnStretch(2, 6)
            self.dlg.gridLayout_3.setColumnStretch(3, 0)
            # Keep top-right controls and tools aligned in a stable layout.
            self.dlg.gridLayout_3.addWidget(self.dlg.widget, 0, 2, 1, 2)
            self.dlg.gridLayout_3.addLayout(self.dlg.gridLayout, 1, 2, 1, 2)
            self.dlg.gridLayout_3.setRowStretch(0, 0)
            self.dlg.gridLayout_3.setRowStretch(1, 0)
            self.dlg.gridLayout_3.setRowStretch(2, 0)
            self.dlg.gridLayout_3.setRowStretch(3, 1)
        if hasattr(self.dlg, "verticalLayout_3"):
            # Keep a visible gap between left widgets and separator line.
            self.dlg.verticalLayout_3.setContentsMargins(0, 0, 10, 0)
            self.dlg.verticalLayout_3.setSpacing(8)
            # Ensure Drawing Options keeps enough vertical room at different DPI scales.
            self.dlg.verticalLayout_3.setStretch(0, 0)
            self.dlg.verticalLayout_3.setStretch(1, 3)
            self.dlg.verticalLayout_3.setStretch(2, 0)
            self.dlg.verticalLayout_3.setStretch(3, 3)
            self.dlg.verticalLayout_3.setStretch(4, 4)
        if hasattr(self.dlg, "widget"):
            self.dlg.widget.setMinimumHeight(220)
            self.dlg.widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        if self.left_nav_widget is not None:
            self.left_nav_widget.setMinimumHeight(180)
            self.left_nav_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        if hasattr(self.dlg, "line"):
            self.dlg.line.setFixedWidth(2)
            self.dlg.line.setStyleSheet("color: #9a9a9a;")
        if self.bottom_controls_widget is None:
            self._reposition_bottom_controls()

    def _init_name_raster_panel(self):
        if self.name_raster_panel is not None or self.dlg is None:
            return

        if hasattr(self.dlg, "nomeraster"):
            self.dlg.nomeraster.hide()

        panel = QWidget(self.dlg.layoutWidget)
        panel_layout = QVBoxLayout(panel)
        panel_layout.setContentsMargins(2, 2, 2, 2)
        panel_layout.setSpacing(4)

        title = QLabel("Name Raster:")
        title.setStyleSheet("color: #202020; font-size: 9pt; font-weight: 600;")
        panel_layout.addWidget(title)

        lines = []
        for _ in range(4):
            row = QLabel("-")
            row.setStyleSheet("color: #202020; font-size: 9pt;")
            row.setWordWrap(True)
            panel_layout.addWidget(row)
            lines.append(row)

        self.name_raster_panel = panel
        self.name_raster_title = title
        self.name_raster_lines = lines
        panel.setMinimumHeight(56)
        panel.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Minimum)
        if hasattr(self.dlg, "verticalLayout_3"):
            self.dlg.verticalLayout_3.addWidget(panel)
        else:
            self.dlg.gridLayout_3.addWidget(panel, 2, 0, 1, 4)
        self._render_name_raster_lines([])

    def _reposition_bottom_controls(self):
        """Place legacy absolute-position controls directly under the main layout block."""
        if self.dlg is None or not hasattr(self.dlg, "layoutWidget"):
            return
        lw = self.dlg.layoutWidget.geometry()
        base_y = lw.y() + lw.height() + 10

        # Column anchors used by the legacy bottom section.
        x_btn = 180
        x_col1 = 300
        x_col2 = 420

        y_row1 = base_y + 22
        y_row1_lbl = y_row1 - 20
        y_row2 = y_row1 + 50
        y_row2_lbl = y_row2 - 20
        y_row3 = y_row2 + 50
        y_row3_lbl = y_row3 - 20

        # Row 1: orientation + x0/x1
        if hasattr(self.dlg, "selectGridPointsButton"):
            self.dlg.selectGridPointsButton.move(x_btn, y_row1)
        if hasattr(self.dlg, "lineEditX0Y0"):
            self.dlg.lineEditX0Y0.move(x_col1, y_row1)
        if hasattr(self.dlg, "lineEditX1Y0"):
            self.dlg.lineEditX1Y0.move(x_col2, y_row1)

        # Row 2: y0/y1
        if hasattr(self.dlg, "lineEditY0"):
            self.dlg.lineEditY0.move(x_col1, y_row2)
        if hasattr(self.dlg, "lineEditX0Y1"):
            self.dlg.lineEditX0Y1.move(x_col2, y_row2)

        # Row 3: draw polygon + name + cell sizes
        if hasattr(self.dlg, "createGridButton"):
            self.dlg.createGridButton.move(90, y_row3)
        if hasattr(self.dlg, "lineEditAreaNames"):
            self.dlg.lineEditAreaNames.move(208, y_row3)
        if hasattr(self.dlg, "lineEditDistanceX"):
            self.dlg.lineEditDistanceX.move(x_col1, y_row3)
        if hasattr(self.dlg, "lineEditDistanceY"):
            self.dlg.lineEditDistanceY.move(x_col2, y_row3)
        if self.internal_grid_checkbox is not None:
            self.internal_grid_checkbox.move(208, y_row3_lbl - 2)

        # Labels aligned to related fields.
        if hasattr(self.dlg, "labelx_3"):
            self.dlg.labelx_3.move(x_col1, y_row2_lbl)
        if hasattr(self.dlg, "labelx_4"):
            self.dlg.labelx_4.move(x_col2, y_row2_lbl)
        if hasattr(self.dlg, "labelx_6"):
            self.dlg.labelx_6.move(x_col1, y_row3_lbl)
            self.dlg.labelx_6.setFixedWidth(86)
            self.dlg.labelx_6.setText("Cell X (m)")
            self.dlg.labelx_6.setStyleSheet("color: #202020; font-size: 9pt;")
        if hasattr(self.dlg, "labelx_5"):
            self.dlg.labelx_5.move(x_col2, y_row3_lbl)
            self.dlg.labelx_5.setFixedWidth(86)
            self.dlg.labelx_5.setText("Cell Y (m)")
            self.dlg.labelx_5.setStyleSheet("color: #202020; font-size: 9pt;")

        # Hide legacy x0/x1 labels in the top layout and create aligned labels near fields.
        if hasattr(self.dlg, "labelx"):
            self.dlg.labelx.hide()
        if hasattr(self.dlg, "labelx_2"):
            self.dlg.labelx_2.hide()
        if not hasattr(self, "_coord_x0_label"):
            self._coord_x0_label = QLabel("x0", self.dlg)
            self._coord_x1_label = QLabel("x1", self.dlg)
            self._coord_x0_label.setStyleSheet("color: #202020; font-size: 9pt;")
            self._coord_x1_label.setStyleSheet("color: #202020; font-size: 9pt;")
        self._coord_x0_label.setGeometry(x_col1, y_row1_lbl, 40, 16)
        self._coord_x1_label.setGeometry(x_col2, y_row1_lbl, 40, 16)
        self._coord_x0_label.show()
        self._coord_x1_label.show()

    def _render_name_raster_lines(self, lines):
        if self.name_raster_panel is None:
            return
        normalized = [str(x) for x in (lines or []) if str(x).strip()]
        if not normalized:
            normalized = ["No raster loaded"]
        for idx, row in enumerate(self.name_raster_lines):
            if idx < len(normalized):
                row.setText(normalized[idx])
                row.show()
            else:
                row.setText("")
                row.hide()

    def _build_name_lines_for_selected_groups(self):
        if self.dlg is None:
            return []
        selected_group_items = self.dlg.groupListWidget.selectedItems()
        if not selected_group_items:
            return []

        value = self.dlg.Dial.value()
        lines = []
        for group_item in selected_group_items:
            group_name = group_item.text().strip()
            group = self._get_or_create_plugin_qgis_group(group_name)
            raster_nodes = [
                child for child in group.children()
                if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer)
            ]
            if not raster_nodes:
                continue
            index = min(value, len(raster_nodes) - 1)
            visible_raster_name = raster_nodes[index].layer().name()
            lines.append(f"[{group_name}] {visible_raster_name}")
        return lines

    def _qgis_theme_icon(self, *names):
        for name in names:
            if not name:
                continue
            normalized = name if str(name).startswith("/") else f"/{name}"
            icon = QgsApplication.getThemeIcon(normalized)
            if icon is not None and not icon.isNull():
                return icon
        return QIcon()

    def _set_button_icon(self, button, *theme_names):
        if button is None:
            return
        icon = self._qgis_theme_icon(*theme_names)
        if not icon.isNull():
            button.setIcon(icon)
            button.setIconSize(QSize(16, 16))

    def _apply_button_icons(self):
        # Use QGIS native theme icons when available.
        self._set_button_icon(getattr(self.dlg, "createGroupButton", None), "mActionAddGroup.svg", "mActionNewVectorLayer.svg")
        self._set_button_icon(getattr(self.dlg, "zoomSelectedGroupsButton", None), "mActionZoomToSelected.svg", "mActionZoomFullExtent.svg")
        self._set_button_icon(getattr(self, "import_groups_button", None), "mActionOptions.svg", "mActionPropertiesWidget.svg")
        self._set_button_icon(getattr(self.dlg, "createGridButton", None), "mActionCapturePolygon.svg", "mActionNewVectorLayer.svg")
        self._set_button_icon(getattr(self.dlg, "selectGridPointsButton", None), "mActionCapturePoint.svg", "mActionMoveVertex.svg")
        self._set_button_icon(getattr(self, "enhance_minmax_button", None), "mActionRasterHistogram.svg", "mActionOptions.svg")
        self._set_button_icon(getattr(self, "enhance_batch_button", None), "mActionRasterHistogram.svg", "mActionFilter2.svg")
        self._set_button_icon(getattr(self, "save_style_button", None), "mActionFileSave.svg", "mActionSaveAs.svg")
        self._set_button_icon(getattr(self, "load_style_button", None), "mActionFileOpen.svg", "mActionAddRasterLayer.svg")
        self._set_button_icon(getattr(self, "export_layout_button", None), "mActionSaveAsPDF.svg", "mActionSaveAs.svg")
        self._set_button_icon(getattr(self, "help_button", None), "mActionHelpContents.svg", "mActionOptions.svg")
        self._set_button_icon(getattr(self, "export_button", None), "mActionSaveAs.svg", "mActionFileSave.svg")

    def _build_grid_options_controls(self):
        (
            self.snap_checkbox,
            self.snap_mode_combo,
            self.snap_tolerance_spin,
            self.snap_units_combo,
            self.ortho_checkbox,
            self.ortho_base_checkbox,
            self.keep_area_checkbox,
            self.dimension_mode_combo,
            self.help_button,
            self.export_button,
            self.base_angle_label,
            self.length_label,
        ) = build_grid_options_controls(
            self.dlg.horizontalLayout_2,
            use_snap=self.grid_use_snap,
            snap_mode=self.grid_snap_mode,
            snap_tolerance=self.grid_snap_tolerance,
            snap_units=self.grid_snap_units,
            force_orthogonal=self.grid_force_orthogonal,
            relative_orthogonal=self.grid_relative_orthogonal,
            keep_source_polygon=self.keep_source_polygon,
            dimension_mode=self.grid_dimension_mode,
        )

    def _notify_info(self, message, duration=6):
        self.iface.messageBar().pushMessage("RasterLinker", message, level=Qgis.Info, duration=duration)

    def _sync_grid_options_from_controls(self):
        if self.snap_checkbox is not None:
            self.grid_use_snap = bool(self.snap_checkbox.isChecked())
        if self.snap_mode_combo is not None:
            mode = self.snap_mode_combo.currentData()
            self.grid_snap_mode = mode if mode in ("all", "vertex_segment", "vertex", "segment", "intersection") else "all"
        if self.snap_tolerance_spin is not None:
            self.grid_snap_tolerance = float(self.snap_tolerance_spin.value())
        if self.snap_units_combo is not None:
            unit = self.snap_units_combo.currentData()
            self.grid_snap_units = unit if unit in ("pixels", "mm", "cm", "map_units") else "pixels"
        if self.ortho_checkbox is not None:
            self.grid_force_orthogonal = bool(self.ortho_checkbox.isChecked())
        if self.ortho_base_checkbox is not None:
            self.grid_relative_orthogonal = bool(self.ortho_base_checkbox.isChecked())
        if self.keep_area_checkbox is not None:
            self.keep_source_polygon = bool(self.keep_area_checkbox.isChecked())
        if self.dimension_mode_combo is not None:
            mode = self.dimension_mode_combo.currentData()
            self.grid_dimension_mode = mode if mode in ("ask", "manual", "canvas") else "ask"
        if self.internal_grid_checkbox is not None:
            self.grid_internal_enabled = bool(self.internal_grid_checkbox.isChecked())
        self._apply_grid_snapping_config()

    def _on_internal_grid_toggled(self, checked):
        enabled = bool(checked)
        if hasattr(self.dlg, "lineEditDistanceX"):
            self.dlg.lineEditDistanceX.setEnabled(enabled)
        if hasattr(self.dlg, "lineEditDistanceY"):
            self.dlg.lineEditDistanceY.setEnabled(enabled)
        label_style = "color: #202020; font-size: 9pt;" if enabled else "color: #6d6d6d; font-size: 9pt;"
        for label in (self.cell_x_label, self.cell_y_label):
            if label is not None:
                label.setStyleSheet(label_style)

    def get_snap_filter(self):
        edge_flag = getattr(QgsPointLocator, "Edge", getattr(QgsPointLocator, "Segment", 0))
        intersection_flag = getattr(QgsPointLocator, "Intersection", 0)
        vertex_flag = getattr(QgsPointLocator, "Vertex", 0)
        all_flag = getattr(QgsPointLocator, "All", vertex_flag | edge_flag | intersection_flag)
        mode = getattr(self, "grid_snap_mode", "all")
        if mode == "vertex":
            return vertex_flag
        if mode == "segment":
            return edge_flag
        if mode == "vertex_segment":
            return vertex_flag | edge_flag
        if mode == "intersection":
            return intersection_flag
        return all_flag

    def _snap_tolerance_pixels(self):
        value = float(getattr(self, "grid_snap_tolerance", 12.0))
        units = getattr(self, "grid_snap_units", "pixels")
        if units == "pixels":
            return value
        if units in ("mm", "cm"):
            dpi = float(self.iface.mapCanvas().logicalDpiX() or 96.0)
            mm_value = value if units == "mm" else value * 10.0
            return mm_value * dpi / 25.4
        return value

    def _apply_grid_snapping_config(self):
        """Apply plugin snap options to the current QGIS snapping config."""
        try:
            project = QgsProject.instance()
            config = QgsSnappingConfig(project.snappingConfig())
            config.setEnabled(bool(self.grid_use_snap))

            if hasattr(QgsSnappingConfig, "AllLayers"):
                config.setMode(QgsSnappingConfig.AllLayers)
            elif hasattr(QgsSnappingConfig, "SnappingMode"):
                config.setMode(QgsSnappingConfig.SnappingMode.AllLayers)

            snap_filter = self.get_snap_filter()
            if hasattr(config, "setTypeFlag"):
                config.setTypeFlag(snap_filter)
            elif hasattr(config, "setType"):
                config.setType(snap_filter)

            if self.grid_snap_units == "map_units":
                config.setUnits(QgsTolerance.MapUnits)
                config.setTolerance(float(self.grid_snap_tolerance))
            else:
                config.setUnits(QgsTolerance.Pixels)
                config.setTolerance(float(self._snap_tolerance_pixels()))

            project.setSnappingConfig(config)
        except Exception:
            # Keep plugin functional even if API differs across QGIS versions.
            pass

    def update_draw_indicators(self, angle_rad=None, length=None):
        if self.base_angle_label is None:
            return
        if angle_rad is None:
            self.base_angle_label.setText("Base: --")
        else:
            angle_deg = (angle_rad * 180.0 / 3.141592653589793) % 360.0
            self.base_angle_label.setText(f"Base: {angle_deg:.1f}deg")

        if self.length_label is not None:
            if length is None:
                self.length_label.setText("Len: --")
            else:
                self.length_label.setText(f"Len: {length:.2f}")

    # Backward compatibility with existing calls.
    def update_base_angle_indicator(self, angle_rad=None):
        self.update_draw_indicators(angle_rad=angle_rad, length=None)

    def show_grid_help(self):
        help_text = (
            "Draw workflow:\n"
            "- Left click: add vertex\n"
            "- Right click / Enter: finish polygon\n"
            "- ESC: cancel\n"
            "- D or middle-click: lock orientation and choose dimensions\n"
            "- X: toggle ortho lock from keyboard\n"
            "- Ortho base: orthogonal snapping relative to drawn base\n"
            "- Snap to: All / Vertex / Segment / Intersection\n"
            "- Tol: snap tolerance (px, mm, cm, or map units)\n"
            "- Dimension Input: Ask / Manual / Canvas for length-width input"
        )
        QMessageBox.information(self.dlg, "Grid Help", help_text)

    def export_last_grid_to_gpkg(self):
        if self.last_grid_layer is None:
            QMessageBox.warning(self.dlg, "Export", "No generated grid found to export.")
            return

        output_path, _ = QFileDialog.getSaveFileName(
            self.dlg,
            "Export Area + Grid",
            "",
            "GeoPackage (*.gpkg)",
        )
        if not output_path:
            return
        if not output_path.lower().endswith(".gpkg"):
            output_path += ".gpkg"

        area_layer = self.last_area_layer
        grid_layer = self.last_grid_layer
        export_targets = []
        if area_layer is not None:
            export_targets.append((area_layer, area_layer.name() or "area"))
        export_targets.append((grid_layer, grid_layer.name() or "grid"))

        transform_context = QgsProject.instance().transformContext()
        try:
            for idx, (layer, layer_name) in enumerate(export_targets):
                opts = QgsVectorFileWriter.SaveVectorOptions()
                opts.driverName = "GPKG"
                opts.fileEncoding = "UTF-8"
                opts.layerName = layer_name
                opts.actionOnExistingFile = (
                    QgsVectorFileWriter.CreateOrOverwriteFile
                    if idx == 0
                    else QgsVectorFileWriter.CreateOrOverwriteLayer
                )
                result = QgsVectorFileWriter.writeAsVectorFormatV3(layer, output_path, transform_context, opts)
                err_code = result[0] if isinstance(result, tuple) else result
                err_msg = result[1] if isinstance(result, tuple) and len(result) > 1 and isinstance(result[1], str) else ""
                if err_code != QgsVectorFileWriter.NoError:
                    raise RuntimeError(err_msg or f"Error code {err_code} while exporting {layer_name}.")

            for _, layer_name in export_targets:
                gpkg_layer = QgsVectorLayer(f"{output_path}|layername={layer_name}", layer_name, "ogr")
                if gpkg_layer.isValid():
                    QgsProject.instance().addMapLayer(gpkg_layer)
                else:
                    self._notify_info(f"Exported layer '{layer_name}' but reload failed.", duration=8)

            self._notify_info(f"Exported to {output_path} and loaded in project.", duration=8)
        except Exception as e:
            QMessageBox.critical(self.dlg, "Export Error", f"Unable to export GeoPackage: {e}")

    def _confirm_planar_units_for_grid(self):
        project_crs = QgsProject.instance().crs()
        if not project_crs.isGeographic():
            return True
        answer = QMessageBox.question(
            self.dlg,
            "CRS Warning",
            (
                f"Project CRS is geographic ({project_crs.authid()}). "
                "X/Y lengths are interpreted in degrees, not meters.\n\n"
                "Continue anyway?"
            ),
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No,
        )
        return answer == QMessageBox.Yes
### Create Grid with picked points
    def activate_grid_selection_tool(self):
        """
        Activate tool to orient the grid from 3 canvas picks.
        """
        self._sync_grid_options_from_controls()
        if self._get_grid_dimensions_from_fields() is None:
            QMessageBox.warning(
                self.dlg,
                "Missing Grid Dimensions",
                (
                    "Insert valid numeric values in x0, x1, y0, y1 before setting orientation.\n"
                    "Example: x0=0, x1=10, y0=0, y1=10."
                ),
            )
            return
        QMessageBox.information(
            self.dlg,
            "Set Grid Orientation",
            (
                "Orientation mode is active.\n\n"
                "1) First click: grid origin (0,0)\n"
                "2) Second click: X-axis direction\n"
                "3) Third click: Y-axis direction\n\n"
                "Grid size comes from x0/x1/y0/y1 values.\n"
                "Internal cells are optional and controlled by 'Internal grid'."
            ),
        )
        self.grid_selection_tool = GridSelectionTool(self.iface.mapCanvas(), self)
        self.iface.mapCanvas().setMapTool(self.grid_selection_tool)

    def _get_grid_dimensions_from_fields(self):
        try:
            x0_val = float(self.dlg.lineEditX0Y0.text().strip())
            x1_val = float(self.dlg.lineEditX1Y0.text().strip())
            y0_val = float(self.dlg.lineEditY0.text().strip())
            y1_val = float(self.dlg.lineEditX0Y1.text().strip())
        except Exception:
            return None
        size_x = abs(x1_val - x0_val)
        size_y = abs(y1_val - y0_val)
        if size_x <= 0 or size_y <= 0:
            return None
        return size_x, size_y

    def set_grid_points(self, points):
        """
        Receive 3 orientation points and create grid using dimensions from x0/x1/y0/y1.
        """
        try:
            dims = self._get_grid_dimensions_from_fields()
            if dims is None:
                QMessageBox.warning(self.dlg, "Missing Grid Dimensions", "Invalid x0/x1/y0/y1 values.")
                return
            grid_length_x, grid_length_y = dims

            internal_enabled = bool(self.internal_grid_checkbox.isChecked()) if self.internal_grid_checkbox is not None else True
            if internal_enabled:
                cell_x = float(self.dlg.lineEditDistanceX.text().strip())
                cell_y = float(self.dlg.lineEditDistanceY.text().strip())
                if cell_x <= 0 or cell_y <= 0:
                    QMessageBox.warning(self.dlg, "Invalid Cell Size", "Cell X and Cell Y must be positive.")
                    return
            else:
                cell_x = grid_length_x
                cell_y = grid_length_y

            x0, y0 = points[0].x(), points[0].y()
            x1, y1 = points[1].x(), points[1].y()
            y_axis_point = (points[2].x(), points[2].y())

            raster_crs = QgsProject.instance().crs()
            create_oriented_grid(
                x0,
                y0,
                x1,
                y1,
                cell_x,
                cell_y,
                raster_crs,
                grid_length_x=grid_length_x,
                grid_length_y=grid_length_y,
                y_axis_point=y_axis_point,
            )

            QMessageBox.information(
                self.dlg,
                "Success",
                (
                    f"Oriented grid created.\n"
                    f"Grid size: {grid_length_x:.3f} x {grid_length_y:.3f}\n"
                    f"Cell size: {cell_x:.3f} x {cell_y:.3f}\n"
                    f"Internal grid: {'enabled' if internal_enabled else 'disabled'}"
                ),
            )
        except ValueError as ve:
            QMessageBox.warning(self.dlg, "Error", f"Invalid values: {ve}")
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Grid creation failed: {str(e)}")
###########################
    def add_open_button_to_group(self, group_name):
        """Add an Open button for the selected group."""
        button = QPushButton(f"Open {group_name}")
        button.clicked.connect(lambda: self.open_raster_file_for_group(group_name))
        # Add button to layout next to group name
        layout = self.dlg.groupListWidget.layout()
        layout.addWidget(button)

    def open_raster_file(self):
        """Load a raster into the selected group."""
        selected_group_item = self.dlg.groupListWidget.currentItem()

        if not selected_group_item:
            QMessageBox.warning(self.dlg, "Error", "Select a group before loading a raster.")
            return

        group_name = selected_group_item.text()
        root = QgsProject.instance().layerTreeRoot()
        group = next((g for g in root.children() if g.name() == group_name and g.nodeType() == 0), None)

        if not group:
            QMessageBox.warning(self.dlg, "Error", f"Group '{group_name}' was not found.")
            return

        file_paths, _ = QFileDialog.getOpenFileNames(self.dlg, "Select rasters", "", "Raster files (*.tif *.tiff *.png *.jpg)")
        if file_paths:
            for file_path in file_paths:
                layer_name = os.path.basename(file_path)
                raster_layer = QgsRasterLayer(file_path, layer_name)
                if raster_layer.isValid():
                    QgsProject.instance().addMapLayer(raster_layer, False)
                    layer_node = root.findLayer(raster_layer.id())
                    if layer_node:
                        cloned_node = layer_node.clone()
                        group.addChildNode(cloned_node)
                        root.removeLayer(raster_layer.id())
                    self.populate_raster_list(group_name)
                    QMessageBox.information(self.dlg, "Success", f"Raster '{layer_name}' loaded into group '{group_name}'.")
                else:
                    QMessageBox.warning(self.dlg, "Error", f"File '{layer_name}' is not a valid raster.")

    def _iter_groups_with_path(self, root_group):
        """
        Generatore ricorsivo: restituisce (QgsLayerTreeGroup, path_string).
        path_string Ã¨ tipo: "GruppoPadre/SubGruppo/SubSub".
        """
        for child in root_group.children():
            if isinstance(child, QgsLayerTreeGroup):
                path = child.name()
                yield child, path
                # ricorsione: prefissa il path del padre
                for sub_group, sub_path in self._iter_groups_with_path(child):
                    yield sub_group, f"{path}/{sub_path}"

    def _find_group_by_path(self, path):
        """
        Cerca un QgsLayerTreeGroup partendo da un path "A/B/C".
        Ritorna QgsLayerTreeGroup o None.
        """
        if not path:
            return None

        parts = [p for p in path.split("/") if p]
        root = QgsProject.instance().layerTreeRoot()
        current = root

        for name in parts:
            next_group = None
            for ch in current.children():
                if isinstance(ch, QgsLayerTreeGroup) and ch.name() == name:
                    next_group = ch
                    break
            if next_group is None:
                return None
            current = next_group

        return current

    def _set_name_raster_label(self, raster_name=None):
        """Update 'Name Raster' label in GUI."""
        if raster_name:
            self._render_name_raster_lines([raster_name])
        else:
            self._render_name_raster_lines([])

    def _active_project_root(self):
        if self.project_manager_dialog is not None and self.project_manager_dialog.project_root:
            return self.project_manager_dialog.project_root
        if self.project_manager_dialog is not None:
            candidate = self.project_manager_dialog.path_edit.text().strip()
            if candidate:
                return candidate
        stored = self.settings.value(self.settings_key_active_project, "", type=str)
        if stored:
            return stored
        return ""

    def _get_preferred_import_crs(self):
        authid = (self.settings.value(self.settings_key_default_import_crs, "", type=str) or "").strip()
        if authid:
            try:
                from qgis.core import QgsCoordinateReferenceSystem
                crs = QgsCoordinateReferenceSystem(authid)
                if crs.isValid():
                    return crs
            except Exception:
                pass
        return QgsProject.instance().crs()

    def _require_project_root(self, notify=True):
        project_root = self._active_project_root()
        if not project_root:
            if notify:
                QMessageBox.warning(
                    self.dlg,
                    "Project Required",
                    "Open RasterLinker Project Manager and create/open a project first.",
                )
            return None
        return project_root

    def _get_plugin_root_group(self):
        root = QgsProject.instance().layerTreeRoot()
        group = next(
            (
                g for g in root.children()
                if isinstance(g, QgsLayerTreeGroup) and g.name() == self.plugin_layer_root_name
            ),
            None,
        )
        if group is None:
            group = root.addGroup(self.plugin_layer_root_name)
        return group

    def _get_or_create_plugin_qgis_group(self, group_name):
        plugin_root = self._get_plugin_root_group()
        group = next(
            (
                g for g in plugin_root.children()
                if isinstance(g, QgsLayerTreeGroup) and g.name() == group_name
            ),
            None,
        )
        if group is None:
            group = plugin_root.addGroup(group_name)
        return group

    def _find_plugin_root_group(self):
        root = QgsProject.instance().layerTreeRoot()
        return next(
            (
                g for g in root.children()
                if isinstance(g, QgsLayerTreeGroup) and g.name() == self.plugin_layer_root_name
            ),
            None,
        )

    def _remove_plugin_qgis_group(self, group_name):
        plugin_root = self._find_plugin_root_group()
        if plugin_root is None:
            return
        target = next(
            (
                g for g in plugin_root.children()
                if isinstance(g, QgsLayerTreeGroup) and g.name() == group_name
            ),
            None,
        )
        if target is not None:
            plugin_root.removeChildNode(target)

    def _iter_plugin_raster_layers(self):
        plugin_root = self._find_plugin_root_group()
        if plugin_root is None:
            return

        for group in plugin_root.children():
            if not isinstance(group, QgsLayerTreeGroup):
                continue
            for child in group.children():
                if not isinstance(child, QgsLayerTreeLayer):
                    continue
                layer = child.layer()
                if isinstance(layer, QgsRasterLayer):
                    yield layer

    def _apply_minmax_to_layer(self, layer):
        # Try direct layer API first (best compatibility when available).
        if hasattr(layer, "setContrastEnhancement"):
            try:
                layer.setContrastEnhancement(
                    QgsContrastEnhancement.StretchToMinimumMaximum,
                    QgsRasterMinMaxOrigin.MinMax,
                )
                layer.triggerRepaint()
                return True
            except Exception:
                pass

        # Fallback: set renderer min/max based on band statistics.
        provider = layer.dataProvider()
        if provider is None:
            return False

        try:
            stats = provider.bandStatistics(1, QgsRasterBandStats.Min | QgsRasterBandStats.Max)
            minimum = stats.minimumValue
            maximum = stats.maximumValue
        except Exception:
            return False

        if minimum is None or maximum is None:
            return False

        renderer = layer.renderer()
        if renderer is None:
            return False

        applied = False
        try:
            if hasattr(renderer, "setClassificationMin"):
                renderer.setClassificationMin(float(minimum))
                applied = True
            if hasattr(renderer, "setClassificationMax"):
                renderer.setClassificationMax(float(maximum))
                applied = True

            if hasattr(renderer, "contrastEnhancement"):
                ce = renderer.contrastEnhancement()
                if ce is not None:
                    ce.setMinimumValue(float(minimum))
                    ce.setMaximumValue(float(maximum))
                    ce.setContrastEnhancementAlgorithm(QgsContrastEnhancement.StretchToMinimumMaximum, True)
                    applied = True
        except Exception:
            return False

        if applied:
            layer.triggerRepaint()
        return applied

    def _catalog_groups_by_name(self, project_root):
        catalog = load_catalog(project_root)
        groups = catalog.get("raster_groups", [])
        return {g.get("name"): g for g in groups if g.get("name")}

    def _visible_plugin_group_names(self):
        plugin_root = self._find_plugin_root_group()
        if plugin_root is None:
            return []
        return [g.name() for g in plugin_root.children() if isinstance(g, QgsLayerTreeGroup)]

    def _apply_group_visibility_selection(self, group_names):
        project_root = self._require_project_root()
        if not project_root:
            return
        by_name = self._catalog_groups_by_name(project_root)
        selected = [name for name in group_names if name in by_name]

        for existing in self._visible_plugin_group_names():
            if existing not in selected:
                self._remove_plugin_qgis_group(existing)

        for name in selected:
            self._get_or_create_plugin_qgis_group(name)

        self.populate_group_list()
        if self.dlg.groupListWidget.count() > 0:
            self.dlg.groupListWidget.setCurrentRow(0)
        self.load_raster(show_message=False)

    def open_group_import_dialog(self):
        project_root = self._require_project_root()
        if not project_root:
            return
        by_name = self._catalog_groups_by_name(project_root)
        groups = [g for g in by_name.values() if g.get("timeslice_ids")]
        if not groups:
            QMessageBox.information(self.dlg, "Import Groups", "No groups with images found in this project.")
            return

        dlg = GroupImportDialog(groups, self._visible_plugin_group_names(), self.dlg)
        if dlg.exec_() != dlg.Accepted:
            return
        self._apply_group_visibility_selection(dlg.selected_group_names())

    def enhance_loaded_images_minmax(self):
        total = 0
        enhanced = 0
        for layer in self._iter_plugin_raster_layers() or []:
            total += 1
            if self._apply_minmax_to_layer(layer):
                enhanced += 1

        if total == 0:
            QMessageBox.information(
                self.dlg,
                "Enhance Min/Max",
                "No loaded images found in RasterLinker groups.",
            )
            return

        self.iface.messageBar().pushInfo(
            "RasterLinker",
            f"Enhance Min/Max applied: {enhanced}/{total} layers.",
        )

    def _iter_group_raster_layers(self, group_name):
        group = self._get_or_create_plugin_qgis_group(group_name)
        for child in group.children():
            if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer):
                yield child.layer()

    def _selected_group_names(self):
        if self.dlg is None:
            return []
        return [it.text().strip() for it in self.dlg.groupListWidget.selectedItems() if it.text().strip()]

    def _apply_value_range_to_layer(self, layer, minimum, maximum):
        if minimum is None or maximum is None:
            return False
        if float(maximum) <= float(minimum):
            return False

        renderer = layer.renderer()
        if renderer is None:
            return False
        applied = False
        try:
            if hasattr(renderer, "setClassificationMin"):
                renderer.setClassificationMin(float(minimum))
                applied = True
            if hasattr(renderer, "setClassificationMax"):
                renderer.setClassificationMax(float(maximum))
                applied = True
            if hasattr(renderer, "contrastEnhancement"):
                ce = renderer.contrastEnhancement()
                if ce is not None:
                    ce.setMinimumValue(float(minimum))
                    ce.setMaximumValue(float(maximum))
                    ce.setContrastEnhancementAlgorithm(QgsContrastEnhancement.StretchToMinimumMaximum, True)
                    applied = True
            if applied:
                layer.triggerRepaint()
            return applied
        except Exception:
            return False

    def enhance_batch_options(self):
        options = ["Min/Max", "Percent Clip (2%)", "StdDev (2Ïƒ)"]
        mode, ok = QInputDialog.getItem(
            self.dlg,
            "Enhance Batch",
            "Enhancement mode:",
            options,
            0,
            False,
        )
        if not ok:
            return

        selected_groups = self._selected_group_names()
        layers = []
        if selected_groups:
            for name in selected_groups:
                layers.extend(list(self._iter_group_raster_layers(name)))
        else:
            layers = list(self._iter_plugin_raster_layers() or [])

        if not layers:
            QMessageBox.information(self.dlg, "Enhance Batch", "No loaded raster layers found.")
            return

        enhanced = 0
        for layer in layers:
            provider = layer.dataProvider()
            if provider is None:
                continue
            try:
                if mode == "StdDev (2Ïƒ)":
                    stats = provider.bandStatistics(
                        1,
                        QgsRasterBandStats.Mean | QgsRasterBandStats.StdDev,
                    )
                    mn = float(stats.mean) - 2.0 * float(stats.stdDev)
                    mx = float(stats.mean) + 2.0 * float(stats.stdDev)
                else:
                    stats = provider.bandStatistics(
                        1,
                        QgsRasterBandStats.Min | QgsRasterBandStats.Max,
                    )
                    mn = float(stats.minimumValue)
                    mx = float(stats.maximumValue)
                    if mode == "Percent Clip (2%)":
                        span = mx - mn
                        mn = mn + 0.02 * span
                        mx = mx - 0.02 * span
                if self._apply_value_range_to_layer(layer, mn, mx):
                    enhanced += 1
            except Exception:
                continue

        self.iface.messageBar().pushInfo(
            "RasterLinker",
            f"Enhance Batch ({mode}) applied: {enhanced}/{len(layers)} layers.",
        )

    def _active_group_item(self):
        if self.dlg is None:
            return None
        return self.dlg.groupListWidget.currentItem()

    def _active_group_record(self):
        project_root = self._require_project_root()
        if not project_root:
            return None, None
        item = self._active_group_item()
        if item is None:
            return project_root, None
        group_id = item.data(Qt.UserRole)
        catalog = load_catalog(project_root)
        rec = next((g for g in catalog.get("raster_groups", []) if g.get("id") == group_id), None)
        return project_root, rec

    def save_selected_group_style(self):
        project_root, group = self._active_group_record()
        if not project_root or group is None:
            QMessageBox.warning(self.dlg, "Save Group Style", "Select one active group first.")
            return
        group_name = group.get("name", "Group")
        layers = list(self._iter_group_raster_layers(group_name))
        if not layers:
            QMessageBox.warning(self.dlg, "Save Group Style", "No loaded layers found for the selected group.")
            return
        style_dir = os.path.join(project_root, "metadata", "group_styles")
        os.makedirs(style_dir, exist_ok=True)
        safe_name = re.sub(r"[^A-Za-z0-9_\-]+", "_", group_name).strip("_") or "group"
        style_path = os.path.join(style_dir, f"{safe_name}.qml")
        ok_msg = layers[0].saveNamedStyle(style_path)
        if isinstance(ok_msg, tuple):
            ok = bool(ok_msg[0])
        else:
            ok = bool(ok_msg)
        if not ok:
            QMessageBox.warning(self.dlg, "Save Group Style", "Unable to save style file.")
            return
        update_raster_group(project_root, group.get("id"), {"style_qml_path": style_path})
        self.iface.messageBar().pushInfo("RasterLinker", f"Group style saved: {style_path}")

    def load_selected_group_style(self):
        project_root, group = self._active_group_record()
        if not project_root or group is None:
            QMessageBox.warning(self.dlg, "Load Group Style", "Select one active group first.")
            return
        style_path = (group.get("style_qml_path") or "").strip()
        if not style_path or not os.path.exists(style_path):
            QMessageBox.warning(self.dlg, "Load Group Style", "No saved style found for this group.")
            return
        group_name = group.get("name", "Group")
        layers = list(self._iter_group_raster_layers(group_name))
        if not layers:
            QMessageBox.warning(self.dlg, "Load Group Style", "No loaded layers found for the selected group.")
            return
        applied = 0
        for lyr in layers:
            try:
                result = lyr.loadNamedStyle(style_path)
                ok = bool(result[0]) if isinstance(result, tuple) else bool(result)
                if ok:
                    lyr.triggerRepaint()
                    applied += 1
            except Exception:
                continue
        self.iface.messageBar().pushInfo("RasterLinker", f"Group style loaded: {applied}/{len(layers)} layers.")

    def export_group_layout_quick(self):
        project_root, group = self._active_group_record()
        if not project_root or group is None:
            QMessageBox.warning(self.dlg, "Export Group Layout", "Select one active group first.")
            return
        group_name = group.get("name", "Group")
        layers = list(self._iter_group_raster_layers(group_name))
        if not layers:
            QMessageBox.warning(self.dlg, "Export Group Layout", "No loaded layers for the selected group.")
            return
        out_dir = QFileDialog.getExistingDirectory(self.dlg, "Select output folder for PDF export")
        if not out_dir:
            return

        project = QgsProject.instance()
        layout_manager = project.layoutManager()
        layout_name = "_RasterLinker_QuickExport"
        old = layout_manager.layoutByName(layout_name)
        if old is not None:
            layout_manager.removeLayout(old)

        layout = QgsPrintLayout(project)
        layout.initializeDefaults()
        layout.setName(layout_name)
        layout_manager.addLayout(layout)

        map_item = QgsLayoutItemMap(layout)
        map_item.attemptMove(QgsLayoutPoint(10, 20, QgsUnitTypes.LayoutMillimeters))
        map_item.attemptResize(QgsLayoutSize(277, 170, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(map_item)

        label_item = QgsLayoutItemLabel(layout)
        label_item.attemptMove(QgsLayoutPoint(10, 8, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(label_item)

        exported = 0
        for lyr in layers:
            try:
                map_item.setLayers([lyr])
                map_item.zoomToExtent(lyr.extent())
                label_item.setText(f"{group_name} - {lyr.name()}")
                label_item.adjustSizeToText()
                safe = re.sub(r"[^A-Za-z0-9_\-]+", "_", lyr.name()).strip("_") or "layer"
                pdf_path = os.path.join(out_dir, f"{group_name}_{safe}.pdf")
                exporter = QgsLayoutExporter(layout)
                result = exporter.exportToPdf(pdf_path, QgsLayoutExporter.PdfExportSettings())
                if result == QgsLayoutExporter.Success:
                    exported += 1
            except Exception:
                continue

        layout_manager.removeLayout(layout)
        self.iface.messageBar().pushInfo(
            "RasterLinker",
            f"Quick layout export completed: {exported}/{len(layers)} PDFs.",
        )


    def populate_group_list(self):
        """Populate the group list in the GUI, including subgroups."""
        try:
            root = QgsProject.instance().layerTreeRoot()
            self.dlg.groupListWidget.clear()

            any_group = False
            for group, path in self._iter_groups_with_path(root):
                any_group = True

                # Indented display text (visual only)
                depth = path.count("/")
                display = ("    " * depth) + group.name()

                item = QListWidgetItem(display)
                # Store full path in item data for later lookup
                item.setData(Qt.UserRole, path)
                self.dlg.groupListWidget.addItem(item)

            if not any_group:
                QMessageBox.warning(self.dlg, "Warning", "No groups found in the layer tree.")

        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while populating groups: {str(e)}")

            QMessageBox.critical(self.dlg, "Error", f"Error while populating groups: {str(e)}")

    def populate_raster_list_from_selected_groups(self):
        """Populate raster list from all currently selected groups (including subgroups)."""
        try:
            self.dlg.rasterListWidget.clear()

            selected_group_items = self.dlg.groupListWidget.selectedItems()
            if not selected_group_items:
                # Optional: just clear and exit
                return

            seen_layer_ids = set()
            added_any = False

            for group_item in selected_group_items:
                group_path = group_item.data(Qt.UserRole) or group_item.text().strip()
                group = self._find_group_by_path(group_path)
                if not group:
                    continue

                # Short group label (last path token)
                group_label = group_path.split("/")[-1] if group_path else group_path

                for child in group.children():
                    if not isinstance(child, QgsLayerTreeLayer):
                        continue
                    layer = child.layer()
                    if not isinstance(layer, QgsRasterLayer):
                        continue

                    layer_id = layer.id()
                    if layer_id in seen_layer_ids:
                        continue
                    seen_layer_ids.add(layer_id)

                    display = f"[{group_label}] {layer.name()}"
                    item = QListWidgetItem(display)
                    # Salvo informazioni utili per usi futuri (zoom al layer, selezione, ecc.)
                    item.setData(Qt.UserRole, layer_id)
                    self.dlg.rasterListWidget.addItem(item)
                    added_any = True

            if not added_any:
                # Optional minimal feedback
                # QMessageBox.information(self.dlg, "Information", "No raster found in selected groups.")
                pass

        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while populating rasters: {str(e)}")


    def populate_raster_list(self, group_path=None):
        """Populate raster list based on selected group path."""
        try:
            self.dlg.rasterListWidget.clear()

            if group_path:
                group = self._find_group_by_path(group_path)

                if group:
                    rasters = [
                        child.layer().name()
                        for child in group.children()
                        if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer)
                    ]
                    self.dlg.rasterListWidget.addItems(rasters)
                else:
                    QMessageBox.warning(self.dlg, "Error", f"Group '{group_path}' not found.")
            else:
                QMessageBox.information(self.dlg, "Information", "Select a group to view rasters.")

        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while populating rasters: {str(e)}")

    def on_group_selected(self, item):
        """Handle selection of a group (including subgroups) in the GUI."""
        if not item:
            QMessageBox.warning(self.dlg, "Error", "Select a valid group.")
            return

        group_path = item.data(Qt.UserRole)
        if not group_path:
            QMessageBox.warning(self.dlg, "Error", "Unable to determine selected group path.")
            return

        # Populate raster list
        self.populate_raster_list(group_path)

        # Find group and set 'Name Raster' to visible raster (or first one)
        group = self._find_group_by_path(group_path)
        if not group:
            self._set_name_raster_label(None)
            return

        raster_nodes = [
            child for child in group.children()
            if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer)
        ]

        if not raster_nodes:
            self._set_name_raster_label(None)
            return

        # Prova a prendere quello attualmente visibile nel Layer Tree, altrimenti il primo
        visible_node = next((n for n in raster_nodes if n.itemVisibilityChecked()), raster_nodes[0])
        self._set_name_raster_label(visible_node.layer().name())
        self.populate_raster_list_from_selected_groups()

 

    def update_visibility_with_dial(self, value):
        """Update raster visibility in selected groups and refresh the 'Name Raster' label."""
        selected_group_items = self.dlg.groupListWidget.selectedItems()
        if not selected_group_items:
            QMessageBox.warning(self.dlg, "Error", "Select at least one group before using the dial.")
            return

        parts_for_label = []  # collects "Group:Raster"

        for group_item in selected_group_items:
            group_path = group_item.data(Qt.UserRole) or group_item.text().strip()

            group = self._find_group_by_path(group_path)
            if not group:
                # Skip, but continue processing other groups
                continue

            raster_nodes = [
                child for child in group.children()
                if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer)
            ]

            if not raster_nodes:
                continue

            index = value % len(raster_nodes)

            for i, node in enumerate(raster_nodes):
                node.setItemVisibilityChecked(i == index)

            visible_raster_name = raster_nodes[index].layer().name()

            # Short label: use last path token (group name)
            group_label = group_path.split("/")[-1] if group_path else group_path
            parts_for_label.append(f"[{group_label}] {visible_raster_name}")

        self._render_name_raster_lines(parts_for_label)


    def zoom_to_selected_groups(self):
        """Zoom canvas extent to layers inside selected groups (including subgroups)."""
        selected_group_items = self.dlg.groupListWidget.selectedItems()
        if not selected_group_items:
            QMessageBox.warning(self.dlg, "Error", "Select at least one group.")
            return

        project = QgsProject.instance()
        project_crs = project.crs()

        combined_extent = None
        found_any_layer = False

        for group_item in selected_group_items:
            group_path = group_item.data(Qt.UserRole) or group_item.text().strip()
            group = self._find_group_by_path(group_path)

            if not group:
                # Skip and continue with next selected group
                continue

            # Get layers (raster/vector) directly in group (not recursive on subgroups,
            # since subgroups are already selectable in list)
            for child in group.children():
                if not isinstance(child, QgsLayerTreeLayer):
                    continue

                layer = child.layer()
                if layer is None:
                    continue

                extent = layer.extent()  # QgsRectangle (in CRS del layer)
                if extent is None or extent.isNull() or extent.isEmpty():
                    continue

                # Transform extent to project CRS if needed
                if layer.crs() != project_crs:
                    try:
                        tr = QgsCoordinateTransform(layer.crs(), project_crs, project)
                        extent = tr.transformBoundingBox(extent)
                    except Exception:
                        # se una trasformazione fallisce, salto quel layer
                        continue

                found_any_layer = True
                if combined_extent is None:
                    combined_extent = QgsRectangle(extent)
                else:
                    combined_extent.combineExtentWith(extent)

        if not found_any_layer or combined_extent is None or combined_extent.isNull() or combined_extent.isEmpty():
            QMessageBox.warning(self.dlg, "Error", "No valid layers found in selected groups.")
            return

        canvas = self.iface.mapCanvas()
        canvas.setExtent(combined_extent)
        canvas.refresh()


    def create_group(self):
        """Create a new group and refresh group list."""
        group_name = self.dlg.groupNameEdit.text().strip()
        if not group_name:
            QMessageBox.warning(self.dlg, "Error", "Group name cannot be empty.")
            return

        root = QgsProject.instance().layerTreeRoot()

        # Ensure group does not already exist
        if any(group.name() == group_name for group in root.children() if group.nodeType() == 0):
            QMessageBox.warning(self.dlg, "Error", f"Group '{group_name}' already exists.")
            return

        # Create group
        root.addGroup(group_name)

        # Add group to UI list
        self.add_group_with_button(group_name)

        QMessageBox.information(self.dlg, "Success", f"Group '{group_name}' created.")

    def add_group_with_button(self, group_name):
        """Add group to group list."""
        # Check if group is already present in the list
        for i in range(self.dlg.groupListWidget.count()):
            if self.dlg.groupListWidget.item(i).text() == group_name:
                QMessageBox.information(self.dlg, "Information", f"Group '{group_name}' is already in the list.")
                return

        # Add group name as list item
        self.dlg.groupListWidget.addItem(group_name)


    def load_raster(self):
        """Open a dialog to select and load multiple rasters into selected group."""
        try:
            # Check whether a group is selected
            selected_group_item = self.dlg.groupListWidget.currentItem()
            if not selected_group_item:
                QMessageBox.warning(self.dlg, "Error", "Select a group before loading rasters.")
                return

            group_name = selected_group_item.text()
            print(f"Selected group: {group_name}")

            # Open file dialog to select multiple files
            file_paths, _ = QFileDialog.getOpenFileNames(
                self.dlg, "Select rasters", "", "Raster files (*.tif *.tiff *.png *.jpg *.img)"
            )
            if not file_paths:
                QMessageBox.warning(self.dlg, "Error", "No file selected.")
                return

            # Find group
            root = QgsProject.instance().layerTreeRoot()
            group = next((g for g in root.children() if g.name() == group_name and g.nodeType() == 0), None)
            if not group:
                QMessageBox.critical(self.dlg, "Error", f"Group '{group_name}' was not found.")
                return

            print(f"Group '{group_name}' found.")

            # Load and add each selected raster
            for file_path in file_paths:
                layer_name = os.path.basename(file_path)
                raster_layer = QgsRasterLayer(file_path, layer_name)

                if not raster_layer.isValid():
                    QMessageBox.warning(self.dlg, "Error", f"File '{layer_name}' is not a valid raster.")
                    continue

                QgsProject.instance().addMapLayer(raster_layer, False)
                print(f"Raster '{layer_name}' added to project with ID: {raster_layer.id()}")

            # Manually create node for layer and add it to group
                cloned_node = QgsLayerTreeLayer(raster_layer)
                group.addChildNode(cloned_node)

            # Refresh raster list
            self.populate_raster_list(group_name)
            QMessageBox.information(self.dlg, "Success", "Rasters added to selected group.")

        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"An unexpected error occurred: {str(e)}")
            print(f"Error: {str(e)}")


    def get_selected_group(self):
        """Return selected group name."""
        selected_group_item = self.dlg.groupListWidget.currentItem()
        if not selected_group_item:
            QMessageBox.warning(self.dlg, "Error", "Select a group before loading a raster.")
            return None
        return selected_group_item.text()

    def open_file_dialog(self):
        """Open a dialog to select a raster file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self.dlg, "Select a raster", "", "Raster files (*.tif *.tiff *.png *.jpg *.img)"
        )
        if not file_path:
            QMessageBox.warning(self.dlg, "Error", "No file selected.")
            return None
        return file_path

    def create_raster_layer(self, file_path):
        """Create a QgsRasterLayer from selected file."""
        layer_name = os.path.basename(file_path)
        raster_layer = QgsRasterLayer(file_path, layer_name)
        if not raster_layer.isValid():
            QMessageBox.critical(self.dlg, "Error", f"File '{layer_name}' is not a valid raster.")
            return None
        QgsProject.instance().addMapLayer(raster_layer, False)
        return raster_layer

    def add_layer_to_group(self, raster_layer, group_name):
        """Add a raster to a specific group."""
        root = QgsProject.instance().layerTreeRoot()
        group = next((g for g in root.children() if g.name() == group_name and g.nodeType() == 0), None)
        if not group:
            QMessageBox.critical(self.dlg, "Error", f"Group '{group_name}' was not found.")
            return

        layer_node = root.findLayer(raster_layer.id())
        if not layer_node:
            QMessageBox.critical(self.dlg, "Error", f"Unable to find node for raster '{raster_layer.name()}'.")
            return

        cloned_node = layer_node.clone()
        group.addChildNode(cloned_node)
        root.removeLayer(raster_layer.id())
        self.populate_raster_list(group_name)
        QMessageBox.information(self.dlg, "Success", f"Raster '{raster_layer.name()}' added to group '{group_name}'.")

    def move_rasters(self):
        """Move selected raster to another group."""
        selected_raster_item = self.dlg.rasterListWidget.currentItem()
        selected_group_item = self.dlg.groupListWidget.currentItem()

        if not selected_raster_item or not selected_group_item:
            QMessageBox.warning(self.dlg, "Error", "Select both a raster and a group.")
            return

        raster_name = selected_raster_item.text()
        target_group_name = selected_group_item.text()

        root = QgsProject.instance().layerTreeRoot()
        target_group = next((g for g in root.children() if g.name() == target_group_name and g.nodeType() == 0), None)

        if not target_group:
            QMessageBox.warning(self.dlg, "Error", f"Group '{target_group_name}' not found.")
            return

        layer = next((l for l in QgsProject.instance().mapLayers().values() if l.name() == raster_name), None)
        if layer:
            layer_node = root.findLayer(layer.id())
            if layer_node:
                cloned_node = layer_node.clone()
                target_group.addChildNode(cloned_node)
                root.removeLayer(layer.id())
                self.populate_raster_list(target_group_name)
                QMessageBox.information(self.dlg, "Success", f"Raster '{raster_name}' moved to group '{target_group_name}'.")
        else:
            QMessageBox.warning(self.dlg, "Error", f"Raster '{raster_name}' not found.")

    # Plugin-catalog driven group/raster management overrides.
    def populate_group_list(self):
        """Populate group list using only groups currently present in QGIS dock."""
        try:
            if self.dlg is None:
                return
            self.dlg.groupListWidget.clear()
            self.dlg.rasterListWidget.clear()

            project_root = self._require_project_root(notify=False)
            if not project_root:
                return

            by_name = self._catalog_groups_by_name(project_root)
            for group_name in self._visible_plugin_group_names():
                group = by_name.get(group_name)
                if not group or not group.get("timeslice_ids"):
                    continue
                item = QListWidgetItem(group_name)
                item.setData(Qt.UserRole, group.get("id"))
                self.dlg.groupListWidget.addItem(item)
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while loading plugin groups: {e}")

    def populate_raster_list_from_selected_groups(self):
        """Populate raster list from selected plugin groups and catalog-imported time-slices only."""
        try:
            self.dlg.rasterListWidget.clear()
            project_root = self._require_project_root()
            if not project_root:
                return

            catalog = load_catalog(project_root)
            groups_by_id = {g.get("id"): g for g in catalog.get("raster_groups", [])}
            timeslices_by_id = {t.get("id"): t for t in catalog.get("timeslices", [])}

            selected_group_items = self.dlg.groupListWidget.selectedItems()
            if not selected_group_items:
                return

            seen_timeslice_ids = set()
            for group_item in selected_group_items:
                group_id = group_item.data(Qt.UserRole)
                group = groups_by_id.get(group_id)
                if not group:
                    continue
                group_label = group.get("name", "Group")
                for timeslice_id in group.get("timeslice_ids", []):
                    if timeslice_id in seen_timeslice_ids:
                        continue
                    rec = timeslices_by_id.get(timeslice_id)
                    if not rec:
                        continue
                    project_path = rec.get("project_path")
                    if not project_path:
                        continue
                    seen_timeslice_ids.add(timeslice_id)
                    display = f"[{group_label}] {rec.get('normalized_name') or rec.get('name') or timeslice_id}"
                    item = QListWidgetItem(display)
                    item.setData(
                        Qt.UserRole,
                        {
                            "timeslice_id": timeslice_id,
                            "project_path": project_path,
                            "group_id": group_id,
                            "group_name": group_label,
                        },
                    )
                    self.dlg.rasterListWidget.addItem(item)
            self._update_navigation_controls()
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while loading rasters: {e}")

    def populate_raster_list(self, group_path=None):
        self.populate_raster_list_from_selected_groups()

    def on_group_selected(self, item):
        if not item:
            self._set_name_raster_label(None)
            return
        self.populate_raster_list_from_selected_groups()
        lines = self._build_name_lines_for_selected_groups()
        if lines:
            self._render_name_raster_lines(lines)
        else:
            first_item = self.dlg.rasterListWidget.item(0)
            self._set_name_raster_label(first_item.text() if first_item else None)
        self.load_raster(show_message=False)

    def on_group_selection_changed(self):
        if self.dlg is None:
            return
        selected_items = self.dlg.groupListWidget.selectedItems()
        if not selected_items:
            self.dlg.rasterListWidget.clear()
            self._set_name_raster_label(None)
            self._update_navigation_controls(0)
            return
        self.populate_raster_list_from_selected_groups()
        self._update_navigation_controls()
        lines = self._build_name_lines_for_selected_groups()
        self._render_name_raster_lines(lines)
        self.load_raster(show_message=False)

    def _update_navigation_controls(self, value=None):
        if self.dlg is None:
            return

        total = self.dlg.rasterListWidget.count()
        max_idx = max(0, total - 1)
        current = self.dlg.Dial.value() if value is None else int(value)
        if current < 0:
            current = 0
        if current > max_idx:
            current = max_idx

        controls = [self.dlg.Dial, self.dlg.dial2]
        for ctrl in controls:
            ctrl.blockSignals(True)
            ctrl.setMinimum(0)
            ctrl.setMaximum(max_idx)
            ctrl.setSingleStep(1)
            if hasattr(ctrl, "setPageStep"):
                ctrl.setPageStep(1)
            ctrl.setEnabled(total > 0)
            ctrl.setValue(current)
            ctrl.blockSignals(False)

    def update_visibility_with_dial(self, value):
        selected_group_items = self.dlg.groupListWidget.selectedItems()
        if not selected_group_items:
            QMessageBox.warning(self.dlg, "Error", "Select at least one group before using the dial.")
            return

        self._update_navigation_controls(value)
        value = self.dlg.Dial.value()

        parts_for_label = []
        for group_item in selected_group_items:
            group_name = group_item.text().strip()
            group = self._get_or_create_plugin_qgis_group(group_name)
            raster_nodes = [
                child for child in group.children()
                if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer)
            ]
            if not raster_nodes:
                continue

            index = min(value, len(raster_nodes) - 1)
            for i, node in enumerate(raster_nodes):
                node.setItemVisibilityChecked(i == index)

            visible_raster_name = raster_nodes[index].layer().name()
            parts_for_label.append(f"[{group_name}] {visible_raster_name}")

        self._render_name_raster_lines(parts_for_label)

    def zoom_to_selected_groups(self):
        selected_group_items = self.dlg.groupListWidget.selectedItems()
        if not selected_group_items:
            QMessageBox.warning(self.dlg, "Error", "Select at least one group.")
            return

        project = QgsProject.instance()
        project_crs = project.crs()
        combined_extent = None
        found_any_layer = False

        for group_item in selected_group_items:
            group_name = group_item.text().strip()
            group = self._get_or_create_plugin_qgis_group(group_name)
            for child in group.children():
                if not isinstance(child, QgsLayerTreeLayer):
                    continue
                layer = child.layer()
                if layer is None:
                    continue

                extent = layer.extent()
                if extent is None or extent.isNull() or extent.isEmpty():
                    continue
                if layer.crs() != project_crs:
                    try:
                        tr = QgsCoordinateTransform(layer.crs(), project_crs, project)
                        extent = tr.transformBoundingBox(extent)
                    except Exception:
                        continue
                found_any_layer = True
                if combined_extent is None:
                    combined_extent = QgsRectangle(extent)
                else:
                    combined_extent.combineExtentWith(extent)

        if not found_any_layer or combined_extent is None or combined_extent.isNull() or combined_extent.isEmpty():
            QMessageBox.warning(self.dlg, "Error", "No valid layers found in selected groups.")
            return
        canvas = self.iface.mapCanvas()
        canvas.setExtent(combined_extent)
        canvas.refresh()

    def create_group(self):
        group_name = self.dlg.groupNameEdit.text().strip()
        if not group_name:
            QMessageBox.warning(self.dlg, "Error", "Group name cannot be empty.")
            return
        project_root = self._require_project_root()
        if not project_root:
            return
        try:
            _, created = create_raster_group(project_root, group_name)
            self._get_or_create_plugin_qgis_group(group_name)
            self.populate_group_list()
            if created:
                QMessageBox.information(self.dlg, "Success", f"Group '{group_name}' created.")
            else:
                QMessageBox.information(self.dlg, "Information", f"Group '{group_name}' is already present.")
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while creating group: {e}")

    def add_group_with_button(self, group_name):
        self.populate_group_list()

    def load_raster(self, show_message=True):
        """Load imported time-slices from selected plugin groups into QGIS layer tree."""
        try:
            project_root = self._require_project_root()
            if not project_root:
                return
            selected_groups = self.dlg.groupListWidget.selectedItems()
            if not selected_groups:
                if show_message:
                    QMessageBox.warning(self.dlg, "Error", "Select at least one plugin group.")
                return

            catalog = load_catalog(project_root)
            groups_by_id = {g.get("id"): g for g in catalog.get("raster_groups", [])}
            timeslices_by_id = {t.get("id"): t for t in catalog.get("timeslices", [])}
            existing_sources = {layer.source() for layer in QgsProject.instance().mapLayers().values()}
            target_crs = self._get_preferred_import_crs()
            loaded_count = 0

            for group_item in selected_groups:
                group_id = group_item.data(Qt.UserRole)
                group = groups_by_id.get(group_id)
                if not group:
                    continue
                group_name = group.get("name", "Group")
                style_path = (group.get("style_qml_path") or "").strip()
                qgis_group = self._get_or_create_plugin_qgis_group(group_name)

                for timeslice_id in group.get("timeslice_ids", []):
                    rec = timeslices_by_id.get(timeslice_id)
                    if not rec:
                        continue
                    path = rec.get("project_path")
                    if not path or not os.path.exists(path) or path in existing_sources:
                        continue
                    layer_name = rec.get("normalized_name") or os.path.basename(path)
                    raster_layer = QgsRasterLayer(path, layer_name)
                    if not raster_layer.isValid():
                        continue
                    if not raster_layer.crs().isValid() and target_crs.isValid():
                        raster_layer.setCrs(target_crs)
                    if style_path and os.path.exists(style_path):
                        try:
                            raster_layer.loadNamedStyle(style_path)
                        except Exception:
                            pass
                    QgsProject.instance().addMapLayer(raster_layer, False)
                    qgis_group.addLayer(raster_layer)
                    existing_sources.add(path)
                    loaded_count += 1

            self.populate_raster_list_from_selected_groups()
            if show_message:
                QMessageBox.information(self.dlg, "Success", f"Time-slice caricate dal catalogo plugin: {loaded_count}")
        except Exception as e:
            if show_message:
                QMessageBox.critical(self.dlg, "Error", f"Error while loading rasters: {e}")

    def get_selected_group(self):
        selected_group_item = self.dlg.groupListWidget.currentItem()
        if not selected_group_item:
            QMessageBox.warning(self.dlg, "Error", "Select a group.")
            return None
        return selected_group_item.data(Qt.UserRole)

    def move_rasters(self):
        """Assign selected imported time-slices to currently selected plugin group."""
        selected_raster_items = self.dlg.rasterListWidget.selectedItems()
        selected_group_item = self.dlg.groupListWidget.currentItem()
        if not selected_raster_items or not selected_group_item:
            QMessageBox.warning(self.dlg, "Error", "Select rasters and target group.")
            return
        project_root = self._require_project_root()
        if not project_root:
            return

        target_group_id = selected_group_item.data(Qt.UserRole)
        timeslice_ids = []
        for item in selected_raster_items:
            payload = item.data(Qt.UserRole) or {}
            tid = payload.get("timeslice_id")
            if tid:
                timeslice_ids.append(tid)
        if not timeslice_ids:
            QMessageBox.warning(self.dlg, "Error", "No valid raster selected.")
            return
        try:
            assign_timeslices_to_group(project_root, target_group_id, timeslice_ids)
            self.populate_raster_list_from_selected_groups()
            QMessageBox.information(self.dlg, "Success", f"Assigned {len(timeslice_ids)} time-slices to group.")
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while assigning raster(s): {e}")


