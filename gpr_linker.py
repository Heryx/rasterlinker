# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GPR
                                 A QGIS plugin
 GPR
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-23
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Giuseppe
        email                : guarino.archeo@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


# -*- coding: utf-8 -*-
"""
GPR - QGIS Plugin Implementation
"""

from qgis.PyQt.QtCore import QSettings, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QFileDialog, QAbstractItemView, QDockWidget, QInputDialog
from qgis.core import (
    QgsPointXY,
    QgsProject,
    QgsRasterLayer,
    QgsLayerTreeLayer,
    QgsLayerTreeGroup,
    QgsCoordinateTransform,
    QgsRectangle,
    QgsVectorLayer,
    QgsVectorFileWriter,
    QgsContrastEnhancement,
    QgsRasterMinMaxOrigin,
    QgsRasterBandStats,
    QgsPrintLayout,
    QgsLayoutItemMap,
    QgsLayoutItemLabel,
    QgsLayoutExporter,
    QgsLayoutPoint,
    QgsLayoutSize,
    QgsUnitTypes,
    Qgis,
)
from PyQt5.QtWidgets import QPushButton, QListWidgetItem, QLabel, QSizePolicy
from .grid_creator import create_oriented_grid
from .grid_selection_tool import GridSelectionTool
from .polygon_grid_creator import create_grid_from_polygon
from .polygon_draw_tool import PolygonDrawTool
from .grid_options_ui import build_grid_options_controls
from .project_manager_dialog import ProjectManagerDialog
from .project_catalog import load_catalog, create_raster_group, assign_timeslices_to_group, update_raster_group
from .group_import_dialog import GroupImportDialog

from .resources import *
from .gpr_linker_dialog import RasterLinkerDialog
import os.path
import re


class RasterLinkerPlugin:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor."""
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.actions = []
        self.menu = self.tr(u'&RasterLinker')
        self.first_start = None
        self.dlg = None
        self.dock_widget = None
        self.settings = QSettings()
        self.settings_group = "RasterLinker"
        self.settings_key_active_project = "RasterLinker/active_project_root"
        self.settings_key_default_import_crs = "RasterLinker/default_import_crs_authid"
        self.grid_use_snap = True
        self.grid_force_orthogonal = False
        self.grid_relative_orthogonal = False
        self.keep_source_polygon = True
        self.grid_dimension_mode = "ask"
        self.snap_checkbox = None
        self.ortho_checkbox = None
        self.ortho_base_checkbox = None
        self.keep_area_checkbox = None
        self.dimension_mode_combo = None
        self.help_button = None
        self.export_button = None
        self.base_angle_label = None
        self.length_label = None
        self.last_area_layer = None
        self.last_grid_layer = None
        self.project_manager_dialog = None
        self.plugin_layer_root_name = "RasterLinker"

    # Translation helper
    def tr(self, message):
        return QCoreApplication.translate('RasterLinker', message)

    # Add actions to the toolbar/menu
    def add_action(self, icon_path, text, callback, parent=None):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        self.iface.addToolBarIcon(action)
        self.iface.addPluginToMenu(self.menu, action)
        self.actions.append(action)
        return action

    def initGui(self):
        """Initialize the GUI."""
        icon_path = ':/plugins/gpr_linker/icon.png'
        self.add_action(icon_path, text=self.tr(u'Raster Linker'), callback=self.run, parent=self.iface.mainWindow())
        self.add_action(icon_path, text=self.tr(u'RasterLinker Project Manager'), callback=self.open_project_manager, parent=self.iface.mainWindow())
        self.first_start = True

    def unload(self):
        """Unload the plugin."""
        if self.dlg is not None:
            self._save_ui_settings()
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&RasterLinker'), action)
            self.iface.removeToolBarIcon(action)
        if self.dock_widget is not None:
            self.iface.removeDockWidget(self.dock_widget)
            self.dock_widget.deleteLater()
            self.dock_widget = None
            self.dlg = None

    def run(self):
        """Esegue il plugin."""
        if self.first_start:
            self.first_start = False
            self.dlg = RasterLinkerDialog()
            self.dock_widget = QDockWidget(self.tr(u"Raster Linker"), self.iface.mainWindow())
            self.dock_widget.setObjectName("RasterLinkerDockWidget")
            self.dock_widget.setWidget(self.dlg)
            self.dock_widget.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dock_widget)
            self.populate_group_list()
            self.dlg.groupListWidget.setSelectionMode(QAbstractItemView.ExtendedSelection)
            self.dlg.createGridButton.setEnabled(True)
            self.dlg.selectGridPointsButton.setEnabled(True)
            self.dlg.selectGridPointsButton.setText("Set Orientation")
            self.dlg.selectGridPointsButton.setMinimumWidth(120)
            if hasattr(self.dlg, "Ok"):
                self.dlg.Ok.hide()
            if hasattr(self.dlg, "openButton"):
                self.dlg.openButton.hide()
            self.dlg.lineEditDistanceX.setEnabled(True)
            self.dlg.lineEditDistanceY.setEnabled(True)
            self.dlg.lineEditAreaNames.setEnabled(True)
            self.dlg.lineEditX0Y0.setEnabled(True)
            self.dlg.lineEditX1Y0.setEnabled(True)
            self.dlg.lineEditY0.setEnabled(True)
            self.dlg.lineEditX0Y1.setEnabled(True)

            # Collega i segnali ai metodi
            self.dlg.createGroupButton.clicked.connect(self.create_group)
            #self.dlg.moveRasterButton.clicked.connect(self.move_rasters)
            #self.dlg.groupListWidget.itemClicked.connect(self.on_group_selected)
            self.dlg.groupListWidget.itemSelectionChanged.connect(self.on_group_selection_changed)
            if hasattr(self.dlg, "openButton"):
                self.dlg.openButton.clicked.connect(self.load_raster)
            self.dlg.selectGridPointsButton.clicked.connect(self.activate_grid_selection_tool)
            if hasattr(self.dlg, "moveRasterButton"):
                self.dlg.moveRasterButton.clicked.connect(self.move_rasters)

            self.dlg.createGridButton.clicked.connect(self.create_grid_from_polygon_layer)

            self.dlg.zoomSelectedGroupsButton.clicked.connect(self.zoom_to_selected_groups)
            self.dlg.zoomSelectedGroupsButton.setText("Load Selected Groups")
            self.import_groups_button = QPushButton("Manage Groups")
            self.import_groups_button.clicked.connect(self.open_group_import_dialog)
            self.dlg.gridLayout.addWidget(self.import_groups_button, 1, 1, 1, 1)
            self.enhance_minmax_button = QPushButton("Enhance Min/Max")
            self.enhance_minmax_button.clicked.connect(self.enhance_loaded_images_minmax)
            self.dlg.gridLayout.addWidget(self.enhance_minmax_button, 5, 0, 1, 1)
            self.enhance_batch_button = QPushButton("Enhance Batch")
            self.enhance_batch_button.clicked.connect(self.enhance_batch_options)
            self.dlg.gridLayout.addWidget(self.enhance_batch_button, 5, 1, 1, 1)
            self.save_style_button = QPushButton("Save Group Style")
            self.save_style_button.clicked.connect(self.save_selected_group_style)
            self.dlg.gridLayout.addWidget(self.save_style_button, 6, 0, 1, 1)
            self.load_style_button = QPushButton("Load Group Style")
            self.load_style_button.clicked.connect(self.load_selected_group_style)
            self.dlg.gridLayout.addWidget(self.load_style_button, 6, 1, 1, 1)
            self.export_layout_button = QPushButton("Export Group Layout")
            self.export_layout_button.clicked.connect(self.export_group_layout_quick)
            self.dlg.gridLayout.addWidget(self.export_layout_button, 7, 0, 1, 2)

            draw_label = QLabel("Drawing")
            image_label = QLabel("Images")
            draw_label.setStyleSheet("font-weight:600;")
            image_label.setStyleSheet("font-weight:600;")
            self.dlg.gridLayout.addWidget(draw_label, 3, 0, 1, 2)
            self.dlg.gridLayout.addWidget(image_label, 4, 0, 1, 2)

            # Preimposta valori predefiniti
            self.dlg.lineEditDistanceX.setText("1.0")  # Valore predefinito per distanza X
            self.dlg.lineEditDistanceY.setText("1.0")  # Valore predefinito per distanza Y
            self.dlg.lineEditAreaNames.setPlaceholderText("Nome area | prefisso sottocelle")
            self.dlg.lineEditAreaNames.setToolTip(
                "Area naming field. Format: AreaName|CellPrefix (prefix optional)."
            )
            self.dlg.lineEditAreaNames.setAccessibleName("lineEditAreaNames")
            self._load_ui_settings()
            self._build_grid_options_controls()
            self._connect_persistent_fields()
            self._tune_visual_layout()

            # Collega il dial alla funzione di aggiornamento
            self.dlg.Dial.valueChanged.connect(self.update_visibility_with_dial)
            self.dlg.dial2.valueChanged.connect(self.update_visibility_with_dial)

        self.dock_widget.show()
        self.dock_widget.raise_()
        if not self._active_project_root():
            self._notify_info(
                "No active project linked. Open 'RasterLinker Project Manager' and create/open a project.",
                duration=8,
            )

    def open_project_manager(self):
        if self.project_manager_dialog is None:
            self.project_manager_dialog = ProjectManagerDialog(
                self.iface,
                self.iface.mainWindow(),
                on_project_updated=self._on_project_manager_updated,
            )
        self.project_manager_dialog.show()
        self.project_manager_dialog.raise_()
        if self.dlg is not None:
            self.populate_group_list()

    def _on_project_manager_updated(self):
        if self.dlg is not None:
            self.populate_group_list()
            self.populate_raster_list_from_selected_groups()

    def create_grid_from_polygon_layer(self):
        """
        Draw a polygon interactively and create a grid from it.
        """
        try:
            # Activate polygon drawing tool
            self.polygon_draw_tool = PolygonDrawTool(self.iface.mapCanvas(), self)
            self.iface.mapCanvas().setMapTool(self.polygon_draw_tool)

            self._notify_info(
                "Draw area: left-click vertices, right-click/Enter to close, ESC to cancel. "
                "Oriented rectangle: first click origin, then D/middle-click for dimensions. "
                "Dock: Snap, Ortho 0/90, Mode. Name: Area|Prefix."
            )
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while activating drawing tool: {e}")

    
    def create_grid_from_drawn_polygon(self, polygon_layer):
        """
        Create a grid based on the polygon drawn by the user.
        """
        try:
            # Read spacing values from UI
            distance_x = float(self.dlg.lineEditDistanceX.text().strip())
            distance_y = float(self.dlg.lineEditDistanceY.text().strip())
            area_name, cell_prefix = self._get_grid_names_from_ui()
            polygon_layer.setName(area_name)
            if not self._confirm_planar_units_for_grid():
                return

            # Create grid
            grid_layer = create_grid_from_polygon(
                polygon_layer,
                distance_x,
                distance_y,
                area_name=area_name,
                cell_prefix=cell_prefix,
                max_cells=120000,
            )
            self.last_area_layer = polygon_layer
            self.last_grid_layer = grid_layer

            if not self.keep_source_polygon and QgsProject.instance().mapLayer(polygon_layer.id()) is not None:
                QgsProject.instance().removeMapLayer(polygon_layer.id())

            self._notify_info(f"Area '{area_name}' created. Cells with prefix '{cell_prefix}'.")
        except ValueError as ve:
            QMessageBox.warning(self.dlg, "Error", f"Error: {ve}")
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while creating grid: {e}")

    def _get_grid_names_from_ui(self):
        """
        Estrae i nomi da lineEditAreaNames.
        Formato supportato: "NomeArea|PrefissoCelle"
        Se manca il prefisso: "NomeArea" -> prefisso automatico.
        """
        raw_value = self.dlg.lineEditAreaNames.text().strip()
        if not raw_value:
            area_name = "Area_Indagine"
            return area_name, f"{area_name}_cell"

        if "|" in raw_value:
            parts = [p.strip() for p in raw_value.split("|", 1)]
            area_name = parts[0] or "Area_Indagine"
            cell_prefix = parts[1] or f"{area_name}_cell"
            return area_name, cell_prefix

        area_name = raw_value
        return area_name, f"{area_name}_cell"

    def _settings_key(self, key):
        return f"{self.settings_group}/{key}"

    def _load_ui_settings(self):
        self.grid_use_snap = self.settings.value(self._settings_key("grid/use_snap"), True, type=bool)
        self.grid_force_orthogonal = self.settings.value(self._settings_key("grid/force_orthogonal"), False, type=bool)
        self.grid_relative_orthogonal = self.settings.value(self._settings_key("grid/relative_orthogonal"), False, type=bool)
        self.keep_source_polygon = self.settings.value(self._settings_key("grid/keep_source_polygon"), True, type=bool)
        mode = self.settings.value(self._settings_key("grid/dimension_mode"), "ask")
        self.grid_dimension_mode = mode if mode in ("ask", "manual", "canvas") else "ask"

        self.dlg.lineEditDistanceX.setText(
            self.settings.value(self._settings_key("grid/distance_x"), self.dlg.lineEditDistanceX.text())
        )
        self.dlg.lineEditDistanceY.setText(
            self.settings.value(self._settings_key("grid/distance_y"), self.dlg.lineEditDistanceY.text())
        )
        self.dlg.lineEditAreaNames.setText(
            self.settings.value(self._settings_key("grid/area_names"), "")
        )

    def _save_ui_settings(self):
        self._sync_grid_options_from_controls()
        self.settings.setValue(self._settings_key("grid/distance_x"), self.dlg.lineEditDistanceX.text().strip())
        self.settings.setValue(self._settings_key("grid/distance_y"), self.dlg.lineEditDistanceY.text().strip())
        self.settings.setValue(self._settings_key("grid/area_names"), self.dlg.lineEditAreaNames.text().strip())
        self.settings.setValue(self._settings_key("grid/use_snap"), self.grid_use_snap)
        self.settings.setValue(self._settings_key("grid/force_orthogonal"), self.grid_force_orthogonal)
        self.settings.setValue(self._settings_key("grid/relative_orthogonal"), self.grid_relative_orthogonal)
        self.settings.setValue(self._settings_key("grid/keep_source_polygon"), self.keep_source_polygon)
        self.settings.setValue(self._settings_key("grid/dimension_mode"), self.grid_dimension_mode)

    def _connect_persistent_fields(self):
        self.dlg.lineEditDistanceX.editingFinished.connect(self._save_ui_settings)
        self.dlg.lineEditDistanceY.editingFinished.connect(self._save_ui_settings)
        self.dlg.lineEditAreaNames.editingFinished.connect(self._save_ui_settings)
        if self.snap_checkbox is not None:
            self.snap_checkbox.toggled.connect(self._save_ui_settings)
        if self.ortho_checkbox is not None:
            self.ortho_checkbox.toggled.connect(self._save_ui_settings)
        if self.ortho_base_checkbox is not None:
            self.ortho_base_checkbox.toggled.connect(self._save_ui_settings)
        if self.keep_area_checkbox is not None:
            self.keep_area_checkbox.toggled.connect(self._save_ui_settings)
        if self.dimension_mode_combo is not None:
            self.dimension_mode_combo.currentIndexChanged.connect(self._save_ui_settings)
        if self.help_button is not None:
            self.help_button.clicked.connect(self.show_grid_help)
        if self.export_button is not None:
            self.export_button.clicked.connect(self.export_last_grid_to_gpkg)

    def _tune_visual_layout(self):
        # Remove obsolete instruction block to recover vertical space.
        if hasattr(self.dlg, "textBrowser"):
            self.dlg.textBrowser.hide()
        if hasattr(self.dlg, "lebelstep"):
            self.dlg.lebelstep.hide()

        # Make navigation controls easier to use.
        self.dlg.dial2.setMinimumSize(165, 165)
        self.dlg.dial2.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.dlg.dial2.setNotchTarget(2.0)
        self.dlg.Dial.setMinimumHeight(34)

        # Improve readability/consistency of action buttons.
        for btn in [
            getattr(self, "import_groups_button", None),
            getattr(self, "enhance_minmax_button", None),
            getattr(self, "enhance_batch_button", None),
            getattr(self, "save_style_button", None),
            getattr(self, "load_style_button", None),
            getattr(self, "export_layout_button", None),
            self.dlg.createGridButton,
            self.dlg.selectGridPointsButton,
            self.dlg.zoomSelectedGroupsButton,
            self.dlg.createGroupButton,
        ]:
            if btn is not None:
                btn.setMinimumHeight(28)

    def _build_grid_options_controls(self):
        (
            self.snap_checkbox,
            self.ortho_checkbox,
            self.ortho_base_checkbox,
            self.keep_area_checkbox,
            self.dimension_mode_combo,
            self.help_button,
            self.export_button,
            self.base_angle_label,
            self.length_label,
        ) = build_grid_options_controls(
            self.dlg.horizontalLayout_2,
            use_snap=self.grid_use_snap,
            force_orthogonal=self.grid_force_orthogonal,
            relative_orthogonal=self.grid_relative_orthogonal,
            keep_source_polygon=self.keep_source_polygon,
            dimension_mode=self.grid_dimension_mode,
        )

    def _notify_info(self, message, duration=6):
        self.iface.messageBar().pushMessage("RasterLinker", message, level=Qgis.Info, duration=duration)

    def _sync_grid_options_from_controls(self):
        if self.snap_checkbox is not None:
            self.grid_use_snap = bool(self.snap_checkbox.isChecked())
        if self.ortho_checkbox is not None:
            self.grid_force_orthogonal = bool(self.ortho_checkbox.isChecked())
        if self.ortho_base_checkbox is not None:
            self.grid_relative_orthogonal = bool(self.ortho_base_checkbox.isChecked())
        if self.keep_area_checkbox is not None:
            self.keep_source_polygon = bool(self.keep_area_checkbox.isChecked())
        if self.dimension_mode_combo is not None:
            mode = self.dimension_mode_combo.currentData()
            self.grid_dimension_mode = mode if mode in ("ask", "manual", "canvas") else "ask"

    def update_draw_indicators(self, angle_rad=None, length=None):
        if self.base_angle_label is None:
            return
        if angle_rad is None:
            self.base_angle_label.setText("Base: --")
        else:
            angle_deg = (angle_rad * 180.0 / 3.141592653589793) % 360.0
            self.base_angle_label.setText(f"Base: {angle_deg:.1f}deg")

        if self.length_label is not None:
            if length is None:
                self.length_label.setText("Len: --")
            else:
                self.length_label.setText(f"Len: {length:.2f}")

    # Backward compatibility with existing calls.
    def update_base_angle_indicator(self, angle_rad=None):
        self.update_draw_indicators(angle_rad=angle_rad, length=None)

    def show_grid_help(self):
        help_text = (
            "Draw workflow:\n"
            "- Left click: add vertex\n"
            "- Right click / Enter: finish polygon\n"
            "- ESC: cancel\n"
            "- D or middle-click: lock orientation and choose dimensions\n"
            "- X: toggle ortho lock from keyboard\n"
            "- Ortho base: orthogonal snapping relative to drawn base\n"
            "- Mode: Ask / Manual / Canvas for length-width input"
        )
        QMessageBox.information(self.dlg, "Grid Help", help_text)

    def export_last_grid_to_gpkg(self):
        if self.last_grid_layer is None:
            QMessageBox.warning(self.dlg, "Export", "No generated grid found to export.")
            return

        output_path, _ = QFileDialog.getSaveFileName(
            self.dlg,
            "Export Area + Grid",
            "",
            "GeoPackage (*.gpkg)",
        )
        if not output_path:
            return
        if not output_path.lower().endswith(".gpkg"):
            output_path += ".gpkg"

        area_layer = self.last_area_layer
        grid_layer = self.last_grid_layer
        export_targets = []
        if area_layer is not None:
            export_targets.append((area_layer, area_layer.name() or "area"))
        export_targets.append((grid_layer, grid_layer.name() or "grid"))

        transform_context = QgsProject.instance().transformContext()
        try:
            for idx, (layer, layer_name) in enumerate(export_targets):
                opts = QgsVectorFileWriter.SaveVectorOptions()
                opts.driverName = "GPKG"
                opts.fileEncoding = "UTF-8"
                opts.layerName = layer_name
                opts.actionOnExistingFile = (
                    QgsVectorFileWriter.CreateOrOverwriteFile
                    if idx == 0
                    else QgsVectorFileWriter.CreateOrOverwriteLayer
                )
                result = QgsVectorFileWriter.writeAsVectorFormatV3(layer, output_path, transform_context, opts)
                err_code = result[0] if isinstance(result, tuple) else result
                err_msg = result[1] if isinstance(result, tuple) and len(result) > 1 and isinstance(result[1], str) else ""
                if err_code != QgsVectorFileWriter.NoError:
                    raise RuntimeError(err_msg or f"Error code {err_code} while exporting {layer_name}.")

            for _, layer_name in export_targets:
                gpkg_layer = QgsVectorLayer(f"{output_path}|layername={layer_name}", layer_name, "ogr")
                if gpkg_layer.isValid():
                    QgsProject.instance().addMapLayer(gpkg_layer)
                else:
                    self._notify_info(f"Exported layer '{layer_name}' but reload failed.", duration=8)

            self._notify_info(f"Exported to {output_path} and loaded in project.", duration=8)
        except Exception as e:
            QMessageBox.critical(self.dlg, "Export Error", f"Unable to export GeoPackage: {e}")

    def _confirm_planar_units_for_grid(self):
        project_crs = QgsProject.instance().crs()
        if not project_crs.isGeographic():
            return True
        answer = QMessageBox.question(
            self.dlg,
            "CRS Warning",
            (
                f"Project CRS is geographic ({project_crs.authid()}). "
                "X/Y lengths are interpreted in degrees, not meters.\n\n"
                "Continue anyway?"
            ),
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No,
        )
        return answer == QMessageBox.Yes
### Create Grid with picked points
    def activate_grid_selection_tool(self):
        """
        Activate tool to orient the grid from 3 canvas picks.
        """
        if self._get_grid_dimensions_from_fields() is None:
            QMessageBox.warning(
                self.dlg,
                "Missing Grid Dimensions",
                (
                    "Insert valid numeric values in x0, x1, y0, y1 before setting orientation.\n"
                    "Example: x0=0, x1=10, y0=0, y1=10."
                ),
            )
            return
        QMessageBox.information(
            self.dlg,
            "Set Grid Orientation",
            (
                "Orientation mode is active.\n\n"
                "1) First click: grid origin (0,0)\n"
                "2) Second click: X-axis direction\n"
                "3) Third click: Y-axis direction\n\n"
                "Grid size comes from x0/x1/y0/y1 values."
            ),
        )
        self.grid_selection_tool = GridSelectionTool(self.iface.mapCanvas(), self)
        self.iface.mapCanvas().setMapTool(self.grid_selection_tool)

    def _get_grid_dimensions_from_fields(self):
        try:
            x0_val = float(self.dlg.lineEditX0Y0.text().strip())
            x1_val = float(self.dlg.lineEditX1Y0.text().strip())
            y0_val = float(self.dlg.lineEditY0.text().strip())
            y1_val = float(self.dlg.lineEditX0Y1.text().strip())
        except Exception:
            return None
        size_x = abs(x1_val - x0_val)
        size_y = abs(y1_val - y0_val)
        if size_x <= 0 or size_y <= 0:
            return None
        return size_x, size_y

    def set_grid_points(self, points):
        """
        Receive 3 orientation points and create grid using dimensions from x0/x1/y0/y1.
        """
        try:
            dims = self._get_grid_dimensions_from_fields()
            if dims is None:
                QMessageBox.warning(self.dlg, "Missing Grid Dimensions", "Invalid x0/x1/y0/y1 values.")
                return
            grid_length_x, grid_length_y = dims

            cell_x = float(self.dlg.lineEditDistanceX.text().strip())
            cell_y = float(self.dlg.lineEditDistanceY.text().strip())
            if cell_x <= 0 or cell_y <= 0:
                QMessageBox.warning(self.dlg, "Invalid Cell Size", "Cell X and Cell Y must be positive.")
                return

            x0, y0 = points[0].x(), points[0].y()
            x1, y1 = points[1].x(), points[1].y()
            y_axis_point = (points[2].x(), points[2].y())

            raster_crs = QgsProject.instance().crs()
            create_oriented_grid(
                x0,
                y0,
                x1,
                y1,
                cell_x,
                cell_y,
                raster_crs,
                grid_length_x=grid_length_x,
                grid_length_y=grid_length_y,
                y_axis_point=y_axis_point,
            )

            QMessageBox.information(
                self.dlg,
                "Success",
                (
                    f"Oriented grid created.\n"
                    f"Grid size: {grid_length_x:.3f} x {grid_length_y:.3f}\n"
                    f"Cell size: {cell_x:.3f} x {cell_y:.3f}"
                ),
            )
        except ValueError as ve:
            QMessageBox.warning(self.dlg, "Error", f"Invalid values: {ve}")
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Grid creation failed: {str(e)}")
###########################
    def add_open_button_to_group(self, group_name):
        """Add an Open button for the selected group."""
        button = QPushButton(f"Open {group_name}")
        button.clicked.connect(lambda: self.open_raster_file_for_group(group_name))
        # Add button to layout next to group name
        layout = self.dlg.groupListWidget.layout()
        layout.addWidget(button)

    def open_raster_file(self):
        """Load a raster into the selected group."""
        selected_group_item = self.dlg.groupListWidget.currentItem()

        if not selected_group_item:
            QMessageBox.warning(self.dlg, "Error", "Select a group before loading a raster.")
            return

        group_name = selected_group_item.text()
        root = QgsProject.instance().layerTreeRoot()
        group = next((g for g in root.children() if g.name() == group_name and g.nodeType() == 0), None)

        if not group:
            QMessageBox.warning(self.dlg, "Error", f"Group '{group_name}' was not found.")
            return

        file_paths, _ = QFileDialog.getOpenFileNames(self.dlg, "Select rasters", "", "Raster files (*.tif *.tiff *.png *.jpg)")
        if file_paths:
            for file_path in file_paths:
                layer_name = os.path.basename(file_path)
                raster_layer = QgsRasterLayer(file_path, layer_name)
                if raster_layer.isValid():
                    QgsProject.instance().addMapLayer(raster_layer, False)
                    layer_node = root.findLayer(raster_layer.id())
                    if layer_node:
                        cloned_node = layer_node.clone()
                        group.addChildNode(cloned_node)
                        root.removeLayer(raster_layer.id())
                    self.populate_raster_list(group_name)
                    QMessageBox.information(self.dlg, "Success", f"Raster '{layer_name}' caricato nel gruppo '{group_name}'.")
                else:
                    QMessageBox.warning(self.dlg, "Error", f"File '{layer_name}' is not a valid raster.")

    def _iter_groups_with_path(self, root_group):
        """
        Generatore ricorsivo: restituisce (QgsLayerTreeGroup, path_string).
        path_string Ã¨ tipo: "GruppoPadre/SubGruppo/SubSub".
        """
        for child in root_group.children():
            if isinstance(child, QgsLayerTreeGroup):
                path = child.name()
                yield child, path
                # ricorsione: prefissa il path del padre
                for sub_group, sub_path in self._iter_groups_with_path(child):
                    yield sub_group, f"{path}/{sub_path}"

    def _find_group_by_path(self, path):
        """
        Cerca un QgsLayerTreeGroup partendo da un path "A/B/C".
        Ritorna QgsLayerTreeGroup o None.
        """
        if not path:
            return None

        parts = [p for p in path.split("/") if p]
        root = QgsProject.instance().layerTreeRoot()
        current = root

        for name in parts:
            next_group = None
            for ch in current.children():
                if isinstance(ch, QgsLayerTreeGroup) and ch.name() == name:
                    next_group = ch
                    break
            if next_group is None:
                return None
            current = next_group

        return current

    def _set_name_raster_label(self, raster_name=None):
        """Update 'Name Raster' label in GUI."""
        if raster_name:
            self.dlg.nomeraster.setText(f"Name Raster: {raster_name}")
        else:
            self.dlg.nomeraster.setText("Name Raster: ")

    def _active_project_root(self):
        if self.project_manager_dialog is not None and self.project_manager_dialog.project_root:
            return self.project_manager_dialog.project_root
        if self.project_manager_dialog is not None:
            candidate = self.project_manager_dialog.path_edit.text().strip()
            if candidate:
                return candidate
        stored = self.settings.value(self.settings_key_active_project, "", type=str)
        if stored:
            return stored
        return ""

    def _get_preferred_import_crs(self):
        authid = (self.settings.value(self.settings_key_default_import_crs, "", type=str) or "").strip()
        if authid:
            try:
                from qgis.core import QgsCoordinateReferenceSystem
                crs = QgsCoordinateReferenceSystem(authid)
                if crs.isValid():
                    return crs
            except Exception:
                pass
        return QgsProject.instance().crs()

    def _require_project_root(self, notify=True):
        project_root = self._active_project_root()
        if not project_root:
            if notify:
                QMessageBox.warning(
                    self.dlg,
                    "Project Required",
                    "Open RasterLinker Project Manager and create/open a project first.",
                )
            return None
        return project_root

    def _get_plugin_root_group(self):
        root = QgsProject.instance().layerTreeRoot()
        group = next(
            (
                g for g in root.children()
                if isinstance(g, QgsLayerTreeGroup) and g.name() == self.plugin_layer_root_name
            ),
            None,
        )
        if group is None:
            group = root.addGroup(self.plugin_layer_root_name)
        return group

    def _get_or_create_plugin_qgis_group(self, group_name):
        plugin_root = self._get_plugin_root_group()
        group = next(
            (
                g for g in plugin_root.children()
                if isinstance(g, QgsLayerTreeGroup) and g.name() == group_name
            ),
            None,
        )
        if group is None:
            group = plugin_root.addGroup(group_name)
        return group

    def _find_plugin_root_group(self):
        root = QgsProject.instance().layerTreeRoot()
        return next(
            (
                g for g in root.children()
                if isinstance(g, QgsLayerTreeGroup) and g.name() == self.plugin_layer_root_name
            ),
            None,
        )

    def _remove_plugin_qgis_group(self, group_name):
        plugin_root = self._find_plugin_root_group()
        if plugin_root is None:
            return
        target = next(
            (
                g for g in plugin_root.children()
                if isinstance(g, QgsLayerTreeGroup) and g.name() == group_name
            ),
            None,
        )
        if target is not None:
            plugin_root.removeChildNode(target)

    def _iter_plugin_raster_layers(self):
        plugin_root = self._find_plugin_root_group()
        if plugin_root is None:
            return

        for group in plugin_root.children():
            if not isinstance(group, QgsLayerTreeGroup):
                continue
            for child in group.children():
                if not isinstance(child, QgsLayerTreeLayer):
                    continue
                layer = child.layer()
                if isinstance(layer, QgsRasterLayer):
                    yield layer

    def _apply_minmax_to_layer(self, layer):
        # Try direct layer API first (best compatibility when available).
        if hasattr(layer, "setContrastEnhancement"):
            try:
                layer.setContrastEnhancement(
                    QgsContrastEnhancement.StretchToMinimumMaximum,
                    QgsRasterMinMaxOrigin.MinMax,
                )
                layer.triggerRepaint()
                return True
            except Exception:
                pass

        # Fallback: set renderer min/max based on band statistics.
        provider = layer.dataProvider()
        if provider is None:
            return False

        try:
            stats = provider.bandStatistics(1, QgsRasterBandStats.Min | QgsRasterBandStats.Max)
            minimum = stats.minimumValue
            maximum = stats.maximumValue
        except Exception:
            return False

        if minimum is None or maximum is None:
            return False

        renderer = layer.renderer()
        if renderer is None:
            return False

        applied = False
        try:
            if hasattr(renderer, "setClassificationMin"):
                renderer.setClassificationMin(float(minimum))
                applied = True
            if hasattr(renderer, "setClassificationMax"):
                renderer.setClassificationMax(float(maximum))
                applied = True

            if hasattr(renderer, "contrastEnhancement"):
                ce = renderer.contrastEnhancement()
                if ce is not None:
                    ce.setMinimumValue(float(minimum))
                    ce.setMaximumValue(float(maximum))
                    ce.setContrastEnhancementAlgorithm(QgsContrastEnhancement.StretchToMinimumMaximum, True)
                    applied = True
        except Exception:
            return False

        if applied:
            layer.triggerRepaint()
        return applied

    def _catalog_groups_by_name(self, project_root):
        catalog = load_catalog(project_root)
        groups = catalog.get("raster_groups", [])
        return {g.get("name"): g for g in groups if g.get("name")}

    def _visible_plugin_group_names(self):
        plugin_root = self._find_plugin_root_group()
        if plugin_root is None:
            return []
        return [g.name() for g in plugin_root.children() if isinstance(g, QgsLayerTreeGroup)]

    def _apply_group_visibility_selection(self, group_names):
        project_root = self._require_project_root()
        if not project_root:
            return
        by_name = self._catalog_groups_by_name(project_root)
        selected = [name for name in group_names if name in by_name]

        for existing in self._visible_plugin_group_names():
            if existing not in selected:
                self._remove_plugin_qgis_group(existing)

        for name in selected:
            self._get_or_create_plugin_qgis_group(name)

        self.populate_group_list()
        if self.dlg.groupListWidget.count() > 0:
            self.dlg.groupListWidget.setCurrentRow(0)
        self.load_raster(show_message=False)

    def open_group_import_dialog(self):
        project_root = self._require_project_root()
        if not project_root:
            return
        by_name = self._catalog_groups_by_name(project_root)
        groups = [g for g in by_name.values() if g.get("timeslice_ids")]
        if not groups:
            QMessageBox.information(self.dlg, "Import Groups", "No groups with images found in this project.")
            return

        dlg = GroupImportDialog(groups, self._visible_plugin_group_names(), self.dlg)
        if dlg.exec_() != dlg.Accepted:
            return
        self._apply_group_visibility_selection(dlg.selected_group_names())

    def enhance_loaded_images_minmax(self):
        total = 0
        enhanced = 0
        for layer in self._iter_plugin_raster_layers() or []:
            total += 1
            if self._apply_minmax_to_layer(layer):
                enhanced += 1

        if total == 0:
            QMessageBox.information(
                self.dlg,
                "Enhance Min/Max",
                "No loaded images found in RasterLinker groups.",
            )
            return

        self.iface.messageBar().pushInfo(
            "RasterLinker",
            f"Enhance Min/Max applied: {enhanced}/{total} layers.",
        )

    def _iter_group_raster_layers(self, group_name):
        group = self._get_or_create_plugin_qgis_group(group_name)
        for child in group.children():
            if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer):
                yield child.layer()

    def _selected_group_names(self):
        if self.dlg is None:
            return []
        return [it.text().strip() for it in self.dlg.groupListWidget.selectedItems() if it.text().strip()]

    def _apply_value_range_to_layer(self, layer, minimum, maximum):
        if minimum is None or maximum is None:
            return False
        if float(maximum) <= float(minimum):
            return False

        renderer = layer.renderer()
        if renderer is None:
            return False
        applied = False
        try:
            if hasattr(renderer, "setClassificationMin"):
                renderer.setClassificationMin(float(minimum))
                applied = True
            if hasattr(renderer, "setClassificationMax"):
                renderer.setClassificationMax(float(maximum))
                applied = True
            if hasattr(renderer, "contrastEnhancement"):
                ce = renderer.contrastEnhancement()
                if ce is not None:
                    ce.setMinimumValue(float(minimum))
                    ce.setMaximumValue(float(maximum))
                    ce.setContrastEnhancementAlgorithm(QgsContrastEnhancement.StretchToMinimumMaximum, True)
                    applied = True
            if applied:
                layer.triggerRepaint()
            return applied
        except Exception:
            return False

    def enhance_batch_options(self):
        options = ["Min/Max", "Percent Clip (2%)", "StdDev (2Ïƒ)"]
        mode, ok = QInputDialog.getItem(
            self.dlg,
            "Enhance Batch",
            "Enhancement mode:",
            options,
            0,
            False,
        )
        if not ok:
            return

        selected_groups = self._selected_group_names()
        layers = []
        if selected_groups:
            for name in selected_groups:
                layers.extend(list(self._iter_group_raster_layers(name)))
        else:
            layers = list(self._iter_plugin_raster_layers() or [])

        if not layers:
            QMessageBox.information(self.dlg, "Enhance Batch", "No loaded raster layers found.")
            return

        enhanced = 0
        for layer in layers:
            provider = layer.dataProvider()
            if provider is None:
                continue
            try:
                if mode == "StdDev (2Ïƒ)":
                    stats = provider.bandStatistics(
                        1,
                        QgsRasterBandStats.Mean | QgsRasterBandStats.StdDev,
                    )
                    mn = float(stats.mean) - 2.0 * float(stats.stdDev)
                    mx = float(stats.mean) + 2.0 * float(stats.stdDev)
                else:
                    stats = provider.bandStatistics(
                        1,
                        QgsRasterBandStats.Min | QgsRasterBandStats.Max,
                    )
                    mn = float(stats.minimumValue)
                    mx = float(stats.maximumValue)
                    if mode == "Percent Clip (2%)":
                        span = mx - mn
                        mn = mn + 0.02 * span
                        mx = mx - 0.02 * span
                if self._apply_value_range_to_layer(layer, mn, mx):
                    enhanced += 1
            except Exception:
                continue

        self.iface.messageBar().pushInfo(
            "RasterLinker",
            f"Enhance Batch ({mode}) applied: {enhanced}/{len(layers)} layers.",
        )

    def _active_group_item(self):
        if self.dlg is None:
            return None
        return self.dlg.groupListWidget.currentItem()

    def _active_group_record(self):
        project_root = self._require_project_root()
        if not project_root:
            return None, None
        item = self._active_group_item()
        if item is None:
            return project_root, None
        group_id = item.data(Qt.UserRole)
        catalog = load_catalog(project_root)
        rec = next((g for g in catalog.get("raster_groups", []) if g.get("id") == group_id), None)
        return project_root, rec

    def save_selected_group_style(self):
        project_root, group = self._active_group_record()
        if not project_root or group is None:
            QMessageBox.warning(self.dlg, "Save Group Style", "Select one active group first.")
            return
        group_name = group.get("name", "Group")
        layers = list(self._iter_group_raster_layers(group_name))
        if not layers:
            QMessageBox.warning(self.dlg, "Save Group Style", "No loaded layers found for the selected group.")
            return
        style_dir = os.path.join(project_root, "metadata", "group_styles")
        os.makedirs(style_dir, exist_ok=True)
        safe_name = re.sub(r"[^A-Za-z0-9_\-]+", "_", group_name).strip("_") or "group"
        style_path = os.path.join(style_dir, f"{safe_name}.qml")
        ok_msg = layers[0].saveNamedStyle(style_path)
        if isinstance(ok_msg, tuple):
            ok = bool(ok_msg[0])
        else:
            ok = bool(ok_msg)
        if not ok:
            QMessageBox.warning(self.dlg, "Save Group Style", "Unable to save style file.")
            return
        update_raster_group(project_root, group.get("id"), {"style_qml_path": style_path})
        self.iface.messageBar().pushInfo("RasterLinker", f"Group style saved: {style_path}")

    def load_selected_group_style(self):
        project_root, group = self._active_group_record()
        if not project_root or group is None:
            QMessageBox.warning(self.dlg, "Load Group Style", "Select one active group first.")
            return
        style_path = (group.get("style_qml_path") or "").strip()
        if not style_path or not os.path.exists(style_path):
            QMessageBox.warning(self.dlg, "Load Group Style", "No saved style found for this group.")
            return
        group_name = group.get("name", "Group")
        layers = list(self._iter_group_raster_layers(group_name))
        if not layers:
            QMessageBox.warning(self.dlg, "Load Group Style", "No loaded layers found for the selected group.")
            return
        applied = 0
        for lyr in layers:
            try:
                result = lyr.loadNamedStyle(style_path)
                ok = bool(result[0]) if isinstance(result, tuple) else bool(result)
                if ok:
                    lyr.triggerRepaint()
                    applied += 1
            except Exception:
                continue
        self.iface.messageBar().pushInfo("RasterLinker", f"Group style loaded: {applied}/{len(layers)} layers.")

    def export_group_layout_quick(self):
        project_root, group = self._active_group_record()
        if not project_root or group is None:
            QMessageBox.warning(self.dlg, "Export Group Layout", "Select one active group first.")
            return
        group_name = group.get("name", "Group")
        layers = list(self._iter_group_raster_layers(group_name))
        if not layers:
            QMessageBox.warning(self.dlg, "Export Group Layout", "No loaded layers for the selected group.")
            return
        out_dir = QFileDialog.getExistingDirectory(self.dlg, "Select output folder for PDF export")
        if not out_dir:
            return

        project = QgsProject.instance()
        layout_manager = project.layoutManager()
        layout_name = "_RasterLinker_QuickExport"
        old = layout_manager.layoutByName(layout_name)
        if old is not None:
            layout_manager.removeLayout(old)

        layout = QgsPrintLayout(project)
        layout.initializeDefaults()
        layout.setName(layout_name)
        layout_manager.addLayout(layout)

        map_item = QgsLayoutItemMap(layout)
        map_item.attemptMove(QgsLayoutPoint(10, 20, QgsUnitTypes.LayoutMillimeters))
        map_item.attemptResize(QgsLayoutSize(277, 170, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(map_item)

        label_item = QgsLayoutItemLabel(layout)
        label_item.attemptMove(QgsLayoutPoint(10, 8, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(label_item)

        exported = 0
        for lyr in layers:
            try:
                map_item.setLayers([lyr])
                map_item.zoomToExtent(lyr.extent())
                label_item.setText(f"{group_name} - {lyr.name()}")
                label_item.adjustSizeToText()
                safe = re.sub(r"[^A-Za-z0-9_\-]+", "_", lyr.name()).strip("_") or "layer"
                pdf_path = os.path.join(out_dir, f"{group_name}_{safe}.pdf")
                exporter = QgsLayoutExporter(layout)
                result = exporter.exportToPdf(pdf_path, QgsLayoutExporter.PdfExportSettings())
                if result == QgsLayoutExporter.Success:
                    exported += 1
            except Exception:
                continue

        layout_manager.removeLayout(layout)
        self.iface.messageBar().pushInfo(
            "RasterLinker",
            f"Quick layout export completed: {exported}/{len(layers)} PDFs.",
        )


    def populate_group_list(self):
        """Populate the group list in the GUI, including subgroups."""
        try:
            root = QgsProject.instance().layerTreeRoot()
            self.dlg.groupListWidget.clear()

            any_group = False
            for group, path in self._iter_groups_with_path(root):
                any_group = True

                # Indented display text (visual only)
                depth = path.count("/")
                display = ("    " * depth) + group.name()

                item = QListWidgetItem(display)
                # Store full path in item data for later lookup
                item.setData(Qt.UserRole, path)
                self.dlg.groupListWidget.addItem(item)

            if not any_group:
                QMessageBox.warning(self.dlg, "Warning", "No groups found in the layer tree.")

        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while populating groups: {str(e)}")

            QMessageBox.critical(self.dlg, "Error", f"Error while populating groups: {str(e)}")

    def populate_raster_list_from_selected_groups(self):
        """Populate raster list from all currently selected groups (including subgroups)."""
        try:
            self.dlg.rasterListWidget.clear()

            selected_group_items = self.dlg.groupListWidget.selectedItems()
            if not selected_group_items:
                # Optional: just clear and exit
                return

            seen_layer_ids = set()
            added_any = False

            for group_item in selected_group_items:
                group_path = group_item.data(Qt.UserRole) or group_item.text().strip()
                group = self._find_group_by_path(group_path)
                if not group:
                    continue

                # etichetta corta del gruppo (ultimo pezzo del path)
                group_label = group_path.split("/")[-1] if group_path else group_path

                for child in group.children():
                    if not isinstance(child, QgsLayerTreeLayer):
                        continue
                    layer = child.layer()
                    if not isinstance(layer, QgsRasterLayer):
                        continue

                    layer_id = layer.id()
                    if layer_id in seen_layer_ids:
                        continue
                    seen_layer_ids.add(layer_id)

                    display = f"[{group_label}] {layer.name()}"
                    item = QListWidgetItem(display)
                    # Salvo informazioni utili per usi futuri (zoom al layer, selezione, ecc.)
                    item.setData(Qt.UserRole, layer_id)
                    self.dlg.rasterListWidget.addItem(item)
                    added_any = True

            if not added_any:
                # Optional minimal feedback
                # QMessageBox.information(self.dlg, "Information", "No raster found in selected groups.")
                pass

        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while populating rasters: {str(e)}")


    def populate_raster_list(self, group_path=None):
        """Populate raster list based on selected group path."""
        try:
            self.dlg.rasterListWidget.clear()

            if group_path:
                group = self._find_group_by_path(group_path)

                if group:
                    rasters = [
                        child.layer().name()
                        for child in group.children()
                        if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer)
                    ]
                    self.dlg.rasterListWidget.addItems(rasters)
                else:
                    QMessageBox.warning(self.dlg, "Error", f"Group '{group_path}' not found.")
            else:
                QMessageBox.information(self.dlg, "Information", "Select a group to view rasters.")

        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while populating rasters: {str(e)}")

    def on_group_selected(self, item):
        """Handle selection of a group (including subgroups) in the GUI."""
        if not item:
            QMessageBox.warning(self.dlg, "Error", "Select a valid group.")
            return

        group_path = item.data(Qt.UserRole)
        if not group_path:
            QMessageBox.warning(self.dlg, "Error", "Unable to determine selected group path.")
            return

        # Popola la lista raster (come giÃ  fai)
        self.populate_raster_list(group_path)

        # Trova il gruppo e imposta 'Name Raster' sul raster visibile (se esiste), altrimenti il primo
        group = self._find_group_by_path(group_path)
        if not group:
            self._set_name_raster_label(None)
            return

        raster_nodes = [
            child for child in group.children()
            if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer)
        ]

        if not raster_nodes:
            self._set_name_raster_label(None)
            return

        # Prova a prendere quello attualmente visibile nel Layer Tree, altrimenti il primo
        visible_node = next((n for n in raster_nodes if n.itemVisibilityChecked()), raster_nodes[0])
        self._set_name_raster_label(visible_node.layer().name())
        self.populate_raster_list_from_selected_groups()

 

    def update_visibility_with_dial(self, value):
        """Update raster visibility in selected groups and refresh the 'Name Raster' label."""
        selected_group_items = self.dlg.groupListWidget.selectedItems()
        if not selected_group_items:
            QMessageBox.warning(self.dlg, "Error", "Select at least one group before using the dial.")
            return

        parts_for_label = []  # collects "Group:Raster"

        for group_item in selected_group_items:
            group_path = group_item.data(Qt.UserRole) or group_item.text().strip()

            group = self._find_group_by_path(group_path)
            if not group:
                # Skip, but continue processing other groups
                continue

            raster_nodes = [
                child for child in group.children()
                if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer)
            ]

            if not raster_nodes:
                continue

            index = value % len(raster_nodes)

            for i, node in enumerate(raster_nodes):
                node.setItemVisibilityChecked(i == index)

            visible_raster_name = raster_nodes[index].layer().name()

            # Short label: use last path token (group name)
            group_label = group_path.split("/")[-1] if group_path else group_path
            parts_for_label.append(f"[{group_label}] {visible_raster_name}")

        # Update label once (after loop)
        if parts_for_label:
            text = " | ".join(parts_for_label)

            # Optional truncation to avoid very long labels
            max_len = 120
            if len(text) > max_len:
                text = text[:max_len - 3] + "..."

            self.dlg.nomeraster.setText(f"Name Raster: {text}")
        else:
            self.dlg.nomeraster.setText("Name Raster: ")


    def zoom_to_selected_groups(self):
        """Zoom canvas extent to layers inside selected groups (including subgroups)."""
        selected_group_items = self.dlg.groupListWidget.selectedItems()
        if not selected_group_items:
            QMessageBox.warning(self.dlg, "Error", "Select at least one group.")
            return

        project = QgsProject.instance()
        project_crs = project.crs()

        combined_extent = None
        found_any_layer = False

        for group_item in selected_group_items:
            group_path = group_item.data(Qt.UserRole) or group_item.text().strip()
            group = self._find_group_by_path(group_path)

            if not group:
                # Skip and continue with next selected group
                continue

            # Get layers (raster/vector) directly in group (not recursive on subgroups,
            # since subgroups are already selectable in list)
            for child in group.children():
                if not isinstance(child, QgsLayerTreeLayer):
                    continue

                layer = child.layer()
                if layer is None:
                    continue

                extent = layer.extent()  # QgsRectangle (in CRS del layer)
                if extent is None or extent.isNull() or extent.isEmpty():
                    continue

                # Trasforma extent nel CRS di progetto se serve
                if layer.crs() != project_crs:
                    try:
                        tr = QgsCoordinateTransform(layer.crs(), project_crs, project)
                        extent = tr.transformBoundingBox(extent)
                    except Exception:
                        # se una trasformazione fallisce, salto quel layer
                        continue

                found_any_layer = True
                if combined_extent is None:
                    combined_extent = QgsRectangle(extent)
                else:
                    combined_extent.combineExtentWith(extent)

        if not found_any_layer or combined_extent is None or combined_extent.isNull() or combined_extent.isEmpty():
            QMessageBox.warning(self.dlg, "Error", "No valid layers found in selected groups.")
            return

        canvas = self.iface.mapCanvas()
        canvas.setExtent(combined_extent)
        canvas.refresh()


    def create_group(self):
        """Create a new group and refresh group list."""
        group_name = self.dlg.groupNameEdit.text().strip()
        if not group_name:
            QMessageBox.warning(self.dlg, "Error", "Group name cannot be empty.")
            return

        root = QgsProject.instance().layerTreeRoot()

        # Ensure group does not already exist
        if any(group.name() == group_name for group in root.children() if group.nodeType() == 0):
            QMessageBox.warning(self.dlg, "Error", f"Group '{group_name}' already exists.")
            return

        # Create group
        root.addGroup(group_name)

        # Add group to UI list
        self.add_group_with_button(group_name)

        QMessageBox.information(self.dlg, "Success", f"Group '{group_name}' created.")

    def add_group_with_button(self, group_name):
        """Add group to group list."""
        # Check if group is already present in the list
        for i in range(self.dlg.groupListWidget.count()):
            if self.dlg.groupListWidget.item(i).text() == group_name:
                QMessageBox.information(self.dlg, "Information", f"Group '{group_name}' is already in the list.")
                return

        # Add group name as list item
        self.dlg.groupListWidget.addItem(group_name)


    def load_raster(self):
        """Open a dialog to select and load multiple rasters into selected group."""
        try:
            # Check whether a group is selected
            selected_group_item = self.dlg.groupListWidget.currentItem()
            if not selected_group_item:
                QMessageBox.warning(self.dlg, "Error", "Select a group before loading rasters.")
                return

            group_name = selected_group_item.text()
            print(f"Selected group: {group_name}")

            # Open file dialog to select multiple files
            file_paths, _ = QFileDialog.getOpenFileNames(
                self.dlg, "Select rasters", "", "Raster files (*.tif *.tiff *.png *.jpg *.img)"
            )
            if not file_paths:
                QMessageBox.warning(self.dlg, "Error", "No file selected.")
                return

            # Trova il gruppo
            root = QgsProject.instance().layerTreeRoot()
            group = next((g for g in root.children() if g.name() == group_name and g.nodeType() == 0), None)
            if not group:
                QMessageBox.critical(self.dlg, "Error", f"Group '{group_name}' was not found.")
                return

            print(f"Group '{group_name}' found.")

            # Load and add each selected raster
            for file_path in file_paths:
                layer_name = os.path.basename(file_path)
                raster_layer = QgsRasterLayer(file_path, layer_name)

                if not raster_layer.isValid():
                    QMessageBox.warning(self.dlg, "Error", f"File '{layer_name}' is not a valid raster.")
                    continue

                QgsProject.instance().addMapLayer(raster_layer, False)
                print(f"Raster '{layer_name}' added to project with ID: {raster_layer.id()}")

            # Manually create node for layer and add it to group
                cloned_node = QgsLayerTreeLayer(raster_layer)
                group.addChildNode(cloned_node)

            # Refresh raster list
            self.populate_raster_list(group_name)
            QMessageBox.information(self.dlg, "Success", "Rasters added to selected group.")

        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"An unexpected error occurred: {str(e)}")
            print(f"Error: {str(e)}")


    def get_selected_group(self):
        """Return selected group name."""
        selected_group_item = self.dlg.groupListWidget.currentItem()
        if not selected_group_item:
            QMessageBox.warning(self.dlg, "Error", "Select a group before loading a raster.")
            return None
        return selected_group_item.text()

    def open_file_dialog(self):
        """Open a dialog to select a raster file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self.dlg, "Select a raster", "", "Raster files (*.tif *.tiff *.png *.jpg *.img)"
        )
        if not file_path:
            QMessageBox.warning(self.dlg, "Error", "No file selected.")
            return None
        return file_path

    def create_raster_layer(self, file_path):
        """Create a QgsRasterLayer from selected file."""
        layer_name = os.path.basename(file_path)
        raster_layer = QgsRasterLayer(file_path, layer_name)
        if not raster_layer.isValid():
            QMessageBox.critical(self.dlg, "Error", f"File '{layer_name}' is not a valid raster.")
            return None
        QgsProject.instance().addMapLayer(raster_layer, False)
        return raster_layer

    def add_layer_to_group(self, raster_layer, group_name):
        """Add a raster to a specific group."""
        root = QgsProject.instance().layerTreeRoot()
        group = next((g for g in root.children() if g.name() == group_name and g.nodeType() == 0), None)
        if not group:
            QMessageBox.critical(self.dlg, "Error", f"Group '{group_name}' was not found.")
            return

        layer_node = root.findLayer(raster_layer.id())
        if not layer_node:
            QMessageBox.critical(self.dlg, "Error", f"Unable to find node for raster '{raster_layer.name()}'.")
            return

        cloned_node = layer_node.clone()
        group.addChildNode(cloned_node)
        root.removeLayer(raster_layer.id())
        self.populate_raster_list(group_name)
        QMessageBox.information(self.dlg, "Success", f"Raster '{raster_layer.name()}' added to group '{group_name}'.")

    def move_rasters(self):
        """Sposta il raster selezionato in un altro gruppo."""
        selected_raster_item = self.dlg.rasterListWidget.currentItem()
        selected_group_item = self.dlg.groupListWidget.currentItem()

        if not selected_raster_item or not selected_group_item:
            QMessageBox.warning(self.dlg, "Error", "Select both a raster and a group.")
            return

        raster_name = selected_raster_item.text()
        target_group_name = selected_group_item.text()

        root = QgsProject.instance().layerTreeRoot()
        target_group = next((g for g in root.children() if g.name() == target_group_name and g.nodeType() == 0), None)

        if not target_group:
            QMessageBox.warning(self.dlg, "Error", f"Group '{target_group_name}' not found.")
            return

        layer = next((l for l in QgsProject.instance().mapLayers().values() if l.name() == raster_name), None)
        if layer:
            layer_node = root.findLayer(layer.id())
            if layer_node:
                cloned_node = layer_node.clone()
                target_group.addChildNode(cloned_node)
                root.removeLayer(layer.id())
                self.populate_raster_list(target_group_name)
                QMessageBox.information(self.dlg, "Success", f"Raster '{raster_name}' moved to group '{target_group_name}'.")
        else:
            QMessageBox.warning(self.dlg, "Error", f"Raster '{raster_name}' not found.")

    # Plugin-catalog driven group/raster management overrides.
    def populate_group_list(self):
        """Populate group list using only groups currently present in QGIS dock."""
        try:
            if self.dlg is None:
                return
            self.dlg.groupListWidget.clear()
            self.dlg.rasterListWidget.clear()

            project_root = self._require_project_root(notify=False)
            if not project_root:
                return

            by_name = self._catalog_groups_by_name(project_root)
            for group_name in self._visible_plugin_group_names():
                group = by_name.get(group_name)
                if not group or not group.get("timeslice_ids"):
                    continue
                item = QListWidgetItem(group_name)
                item.setData(Qt.UserRole, group.get("id"))
                self.dlg.groupListWidget.addItem(item)
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while loading plugin groups: {e}")

    def populate_raster_list_from_selected_groups(self):
        """Populate raster list from selected plugin groups and catalog-imported time-slices only."""
        try:
            self.dlg.rasterListWidget.clear()
            project_root = self._require_project_root()
            if not project_root:
                return

            catalog = load_catalog(project_root)
            groups_by_id = {g.get("id"): g for g in catalog.get("raster_groups", [])}
            timeslices_by_id = {t.get("id"): t for t in catalog.get("timeslices", [])}

            selected_group_items = self.dlg.groupListWidget.selectedItems()
            if not selected_group_items:
                return

            seen_timeslice_ids = set()
            for group_item in selected_group_items:
                group_id = group_item.data(Qt.UserRole)
                group = groups_by_id.get(group_id)
                if not group:
                    continue
                group_label = group.get("name", "Group")
                for timeslice_id in group.get("timeslice_ids", []):
                    if timeslice_id in seen_timeslice_ids:
                        continue
                    rec = timeslices_by_id.get(timeslice_id)
                    if not rec:
                        continue
                    project_path = rec.get("project_path")
                    if not project_path:
                        continue
                    seen_timeslice_ids.add(timeslice_id)
                    display = f"[{group_label}] {rec.get('normalized_name') or rec.get('name') or timeslice_id}"
                    item = QListWidgetItem(display)
                    item.setData(
                        Qt.UserRole,
                        {
                            "timeslice_id": timeslice_id,
                            "project_path": project_path,
                            "group_id": group_id,
                            "group_name": group_label,
                        },
                    )
                    self.dlg.rasterListWidget.addItem(item)
            self._update_navigation_controls()
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while loading rasters: {e}")

    def populate_raster_list(self, group_path=None):
        self.populate_raster_list_from_selected_groups()

    def on_group_selected(self, item):
        if not item:
            self._set_name_raster_label(None)
            return
        self.populate_raster_list_from_selected_groups()
        first_item = self.dlg.rasterListWidget.item(0)
        self._set_name_raster_label(first_item.text() if first_item else None)
        self.load_raster(show_message=False)

    def on_group_selection_changed(self):
        if self.dlg is None:
            return
        selected_items = self.dlg.groupListWidget.selectedItems()
        if not selected_items:
            self.dlg.rasterListWidget.clear()
            self._set_name_raster_label(None)
            self._update_navigation_controls(0)
            return
        self.on_group_selected(selected_items[0])

    def _update_navigation_controls(self, value=None):
        if self.dlg is None:
            return

        total = self.dlg.rasterListWidget.count()
        max_idx = max(0, total - 1)
        current = self.dlg.Dial.value() if value is None else int(value)
        if current < 0:
            current = 0
        if current > max_idx:
            current = max_idx

        controls = [self.dlg.Dial, self.dlg.dial2]
        for ctrl in controls:
            ctrl.blockSignals(True)
            ctrl.setMinimum(0)
            ctrl.setMaximum(max_idx)
            ctrl.setSingleStep(1)
            if hasattr(ctrl, "setPageStep"):
                ctrl.setPageStep(1)
            ctrl.setEnabled(total > 0)
            ctrl.setValue(current)
            ctrl.blockSignals(False)

    def update_visibility_with_dial(self, value):
        selected_group_items = self.dlg.groupListWidget.selectedItems()
        if not selected_group_items:
            QMessageBox.warning(self.dlg, "Error", "Select at least one group before using the dial.")
            return

        self._update_navigation_controls(value)
        value = self.dlg.Dial.value()

        parts_for_label = []
        for group_item in selected_group_items:
            group_name = group_item.text().strip()
            group = self._get_or_create_plugin_qgis_group(group_name)
            raster_nodes = [
                child for child in group.children()
                if isinstance(child, QgsLayerTreeLayer) and isinstance(child.layer(), QgsRasterLayer)
            ]
            if not raster_nodes:
                continue

            index = min(value, len(raster_nodes) - 1)
            for i, node in enumerate(raster_nodes):
                node.setItemVisibilityChecked(i == index)

            visible_raster_name = raster_nodes[index].layer().name()
            parts_for_label.append(f"[{group_name}] {visible_raster_name}")

        if parts_for_label:
            text = " | ".join(parts_for_label)
            if len(text) > 120:
                text = text[:117] + "..."
            self.dlg.nomeraster.setText(f"Name Raster: {text}")
        else:
            self.dlg.nomeraster.setText("Name Raster: ")

    def zoom_to_selected_groups(self):
        selected_group_items = self.dlg.groupListWidget.selectedItems()
        if not selected_group_items:
            QMessageBox.warning(self.dlg, "Error", "Select at least one group.")
            return

        project = QgsProject.instance()
        project_crs = project.crs()
        combined_extent = None
        found_any_layer = False

        for group_item in selected_group_items:
            group_name = group_item.text().strip()
            group = self._get_or_create_plugin_qgis_group(group_name)
            for child in group.children():
                if not isinstance(child, QgsLayerTreeLayer):
                    continue
                layer = child.layer()
                if layer is None:
                    continue

                extent = layer.extent()
                if extent is None or extent.isNull() or extent.isEmpty():
                    continue
                if layer.crs() != project_crs:
                    try:
                        tr = QgsCoordinateTransform(layer.crs(), project_crs, project)
                        extent = tr.transformBoundingBox(extent)
                    except Exception:
                        continue
                found_any_layer = True
                if combined_extent is None:
                    combined_extent = QgsRectangle(extent)
                else:
                    combined_extent.combineExtentWith(extent)

        if not found_any_layer or combined_extent is None or combined_extent.isNull() or combined_extent.isEmpty():
            QMessageBox.warning(self.dlg, "Error", "No valid layers found in selected groups.")
            return
        canvas = self.iface.mapCanvas()
        canvas.setExtent(combined_extent)
        canvas.refresh()

    def create_group(self):
        group_name = self.dlg.groupNameEdit.text().strip()
        if not group_name:
            QMessageBox.warning(self.dlg, "Error", "Group name cannot be empty.")
            return
        project_root = self._require_project_root()
        if not project_root:
            return
        try:
            _, created = create_raster_group(project_root, group_name)
            self._get_or_create_plugin_qgis_group(group_name)
            self.populate_group_list()
            if created:
                QMessageBox.information(self.dlg, "Success", f"Group '{group_name}' created.")
            else:
                QMessageBox.information(self.dlg, "Information", f"Group '{group_name}' is already present.")
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while creating group: {e}")

    def add_group_with_button(self, group_name):
        self.populate_group_list()

    def load_raster(self, show_message=True):
        """Load imported time-slices from selected plugin groups into QGIS layer tree."""
        try:
            project_root = self._require_project_root()
            if not project_root:
                return
            selected_groups = self.dlg.groupListWidget.selectedItems()
            if not selected_groups:
                if show_message:
                    QMessageBox.warning(self.dlg, "Error", "Select at least one plugin group.")
                return

            catalog = load_catalog(project_root)
            groups_by_id = {g.get("id"): g for g in catalog.get("raster_groups", [])}
            timeslices_by_id = {t.get("id"): t for t in catalog.get("timeslices", [])}
            existing_sources = {layer.source() for layer in QgsProject.instance().mapLayers().values()}
            target_crs = self._get_preferred_import_crs()
            loaded_count = 0

            for group_item in selected_groups:
                group_id = group_item.data(Qt.UserRole)
                group = groups_by_id.get(group_id)
                if not group:
                    continue
                group_name = group.get("name", "Group")
                style_path = (group.get("style_qml_path") or "").strip()
                qgis_group = self._get_or_create_plugin_qgis_group(group_name)

                for timeslice_id in group.get("timeslice_ids", []):
                    rec = timeslices_by_id.get(timeslice_id)
                    if not rec:
                        continue
                    path = rec.get("project_path")
                    if not path or not os.path.exists(path) or path in existing_sources:
                        continue
                    layer_name = rec.get("normalized_name") or os.path.basename(path)
                    raster_layer = QgsRasterLayer(path, layer_name)
                    if not raster_layer.isValid():
                        continue
                    if not raster_layer.crs().isValid() and target_crs.isValid():
                        raster_layer.setCrs(target_crs)
                    if style_path and os.path.exists(style_path):
                        try:
                            raster_layer.loadNamedStyle(style_path)
                        except Exception:
                            pass
                    QgsProject.instance().addMapLayer(raster_layer, False)
                    qgis_group.addLayer(raster_layer)
                    existing_sources.add(path)
                    loaded_count += 1

            self.populate_raster_list_from_selected_groups()
            if show_message:
                QMessageBox.information(self.dlg, "Success", f"Time-slice caricate dal catalogo plugin: {loaded_count}")
        except Exception as e:
            if show_message:
                QMessageBox.critical(self.dlg, "Error", f"Error while loading rasters: {e}")

    def get_selected_group(self):
        selected_group_item = self.dlg.groupListWidget.currentItem()
        if not selected_group_item:
            QMessageBox.warning(self.dlg, "Error", "Select a group.")
            return None
        return selected_group_item.data(Qt.UserRole)

    def move_rasters(self):
        """Assign selected imported time-slices to currently selected plugin group."""
        selected_raster_items = self.dlg.rasterListWidget.selectedItems()
        selected_group_item = self.dlg.groupListWidget.currentItem()
        if not selected_raster_items or not selected_group_item:
            QMessageBox.warning(self.dlg, "Error", "Select rasters and target group.")
            return
        project_root = self._require_project_root()
        if not project_root:
            return

        target_group_id = selected_group_item.data(Qt.UserRole)
        timeslice_ids = []
        for item in selected_raster_items:
            payload = item.data(Qt.UserRole) or {}
            tid = payload.get("timeslice_id")
            if tid:
                timeslice_ids.append(tid)
        if not timeslice_ids:
            QMessageBox.warning(self.dlg, "Error", "No valid raster selected.")
            return
        try:
            assign_timeslices_to_group(project_root, target_group_id, timeslice_ids)
            self.populate_raster_list_from_selected_groups()
            QMessageBox.information(self.dlg, "Success", f"Assigned {len(timeslice_ids)} time-slices to group.")
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error while assigning raster(s): {e}")


